# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class RubrikLib_IntConfiguration(Configuration):
    """Configuration for RubrikLib_Int
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        if not base_url:
            base_url = 'https://localhost/api'

        super(RubrikLib_IntConfiguration, self).__init__(base_url)

        self.add_user_agent('rubriklibint/{}'.format(VERSION))


class RubrikLib_Int(object):
    """This is the INTERNAL REST API for Rubrik. We don't guarantee support
    or backward compatibility. Use at your own risk.

    :ivar config: Configuration for client.
    :vartype config: RubrikLib_IntConfiguration

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        self.config = RubrikLib_IntConfiguration(base_url)
        self._client = ServiceClient(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '0.0'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def query_archival_locations(
            self, status=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all archival locations.

        Retrieve information for all archival locations, including ID, type,
        status, address, and bucket count.

        :param status: Filters archival locations by status. Accepted values:
         'active'
        :type status: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ArchivalLocationSummaryListResponse
         <rubriklib_int.models.ArchivalLocationSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ArchivalLocationSummaryListResponse
         <rubriklib_int.models.ArchivalLocationSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/location'

        # Construct parameters
        query_parameters = {}
        if status is not None:
            query_parameters['status'] = self._serialize.query("status", status, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ArchivalLocationSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_archival_location_connect_jobs(
            self, custom_headers=None, raw=False, **operation_config):
        """Get running connection jobs.

        Retrieve a list of all running connection and reconnection jobs for
        archival locations. Returns summary information about the archival
        location and the job.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ArchivalLocationConnectJobListResponse
         <rubriklib_int.models.ArchivalLocationConnectJobListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ArchivalLocationConnectJobListResponse
         <rubriklib_int.models.ArchivalLocationConnectJobListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/location/connect_job'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ArchivalLocationConnectJobListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def disconnect_archival_location(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Disconnect a connected archival location.

        Disconnect an already connected archival location. Initiates a
        asynchronous job to disconnect the archival location and disable that
        location in all associated SLAs.

        :param id: ID of an archival location to disconnect.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/location/disconnect/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_add_archival_location_job_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about a archival location connect job.

        Retrieve the following information about job: ID of job, job status,
        error details, start time of job, end time of job, job type, ID of the
        node, job progress and location id.

        :param id: ID of Job
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobInstanceDetail
         <rubriklib_int.models.JobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobInstanceDetail
         <rubriklib_int.models.JobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/location/job/connect/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('JobInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_reconnect_archival_location_job_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about a archival location reconnect job.

        Retrieve the following information about job: ID of job, job status,
        error details, start time of job, end time of job, job type, ID of the
        node, job progress and location id.

        :param id: ID of Job
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobInstanceDetail
         <rubriklib_int.models.JobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobInstanceDetail
         <rubriklib_int.models.JobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/location/job/reconnect/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('JobInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_archival_location(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a disconnected archival location.

        Delete an archival location that has already been disconnected. Expires
        all snapshots on the location.

        :param id: ID of the archival location
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/location/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_nfs_locations(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summary information about all archival locations that use the NFS
        protocol.

        Returns an array containing archival locations that uses the NFS
        protocol.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NfsLocationDetailListResponse
         <rubriklib_int.models.NfsLocationDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NfsLocationDetailListResponse
         <rubriklib_int.models.NfsLocationDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/nfs'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NfsLocationDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_nfs_location(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Add an archival location that uses the NFS protocol.

        Add a new archival location that uses the NFS protocol. Initiates an
        asynchronous job to establish a connection with the archival location.

        :param definition: Object containing information about the archival
         location.
        :type definition: :class:`NfsLocationCreationDefinition
         <rubriklib_int.models.NfsLocationCreationDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/nfs'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'NfsLocationCreationDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reconnect_nfs(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Reconnect to a specific archival location that uses the NFS protocol.

        Reconnect to a specific archival location that uses the NFS protocol.
        Initiates an asynchronous job to establish a connection with the
        archival location.

        :param request: Archival location credentials.
        :type request: :class:`NfsLocationReconnectSpec
         <rubriklib_int.models.NfsLocationReconnectSpec>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/nfs/reconnect'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'NfsLocationReconnectSpec')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_nfs_location(
            self, id, updated_definition, custom_headers=None, raw=False, **operation_config):
        """Update an archival location that uses the NFS protocol.

        Update the properties of an archival location that uses the NFS
        protocol. .

        :param id: ID of the archival location.
        :type id: str
        :param updated_definition: Object containing information about the
         archival location.
        :type updated_definition: :class:`NfsLocationUpdate
         <rubriklib_int.models.NfsLocationUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NfsLocationDetail
         <rubriklib_int.models.NfsLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NfsLocationDetail
         <rubriklib_int.models.NfsLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/nfs/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(updated_definition, 'NfsLocationUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NfsLocationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_object_store_locations(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summary information about all archival locations that use the S3
        protocol.

        Returns an array containing archival locations that uses the S3
        protocol; such as AWS, Cleversafe, and Scality. Does not retrieve
        archival locations that use the NFS protocol.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ObjectStoreLocationDetailListResponse
         <rubriklib_int.models.ObjectStoreLocationDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ObjectStoreLocationDetailListResponse
         <rubriklib_int.models.ObjectStoreLocationDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/object_store'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ObjectStoreLocationDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_object_store_location(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Add a new archival location that uses the S3 protocol.

        Add a new archival location that uses the S3 protocol; such as AWS,
        Cleversafe, or Scality. Initiates an asynchronous job to establish a
        connection with the archival location.

        :param definition: Object containing information about the archival
         location.
        :type definition: :class:`ObjectStoreLocationDefinition
         <rubriklib_int.models.ObjectStoreLocationDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/object_store'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'ObjectStoreLocationDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reconnect_object_store(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Reconnect to a specific archival location that uses the S3 protocol.

        Reconnect to a specific archival location that uses the S3 protocol.
        Initiates an asynchronous job to establish a connection with the
        archival location.

        :param request: Archival location credentials.
        :type request: :class:`ObjectStoreReconnectDefinition
         <rubriklib_int.models.ObjectStoreReconnectDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/object_store/reconnect'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'ObjectStoreReconnectDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_object_store_location(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information about a specific archival location that uses the S3
        protocol.

        Get the archival location object for a specific archival location that
        uses the S3 protocol.

        :param id: ID of an archival location that uses the S3 protocol.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ObjectStoreLocationDetail
         <rubriklib_int.models.ObjectStoreLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ObjectStoreLocationDetail
         <rubriklib_int.models.ObjectStoreLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/object_store/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ObjectStoreLocationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_object_store_location(
            self, id, updated_definition, custom_headers=None, raw=False, **operation_config):
        """Update an archival location that uses the S3 protocol.

        Update the properties of an archival location that uses the S3
        protocol. IMPORTANT: Specify a bucket count that is equal to or greater
        than the existing bucket count.

        :param id: ID of the archival location.
        :type id: str
        :param updated_definition: Object containing information about the
         archival location.
        :type updated_definition: :class:`ObjectStoreUpdateDefinition
         <rubriklib_int.models.ObjectStoreUpdateDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ObjectStoreLocationDetail
         <rubriklib_int.models.ObjectStoreLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ObjectStoreLocationDetail
         <rubriklib_int.models.ObjectStoreLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/object_store/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(updated_definition, 'ObjectStoreUpdateDefinition')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ObjectStoreLocationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_qstar_locations(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summary information about all Qstar archival locations.

        Returns an array containing all Qstar archival locations.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`QstarLocationSummaryListResponse
         <rubriklib_int.models.QstarLocationSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`QstarLocationSummaryListResponse
         <rubriklib_int.models.QstarLocationSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('QstarLocationSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def clean_qstar_bucket(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Tries to clean up the data in the bucket in
        the Qstar archival location.

        REQUIRES SUPPORT TOKEN - To be used by internal tests to clean the
        buckets. A support token is required for this operation.

        :param definition: Archival definition
        :type definition: :class:`QstarLocationDefinitionWithCredential
         <rubriklib_int.models.QstarLocationDefinitionWithCredential>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'QstarLocationDefinitionWithCredential')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def create_qstar_location(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Add a Qstar archival location.

        Add a new Qstar archival location protocol. Initiates an asynchronous
        job to establish a connection with the archival location.

        :param definition: Object containing information about the archival
         location.
        :type definition: :class:`QstarLocationDefinitionWithCredential
         <rubriklib_int.models.QstarLocationDefinitionWithCredential>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'QstarLocationDefinitionWithCredential')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reconnect_qstar(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Reconnect to a specific Qstar archival location.

        Reconnect to a specific Qstar archival location. Initiates an
        asynchronous job to establish a connection with the archival location.

        :param request: Credentials for accessing the archival location.
        :type request: :class:`QstarLocationDefinitionWithCredential
         <rubriklib_int.models.QstarLocationDefinitionWithCredential>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar/reconnect'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'QstarLocationDefinitionWithCredential')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def remove_qstar_bucket(
            self, request, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Remove all buckets matching given prefix.

        REQUIRES SUPPORT TOKEN - To be used by internal tests to remove all
        Qstar buckets matching given prefix. Returns a list of buckets
        successfully removed. A support token is required for this operation.

        :param request: Remove bucket request configurations
        :type request: :class:`RemoveQstarBucketRequest
         <rubriklib_int.models.RemoveQstarBucketRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar/remove_bucket'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'RemoveQstarBucketRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_qstar_locationby_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary information about an Qstar archival location.

        Returns summary information about a Qstar archival location.

        :param id: ID of the archival location.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`QstarLocationDetail
         <rubriklib_int.models.QstarLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`QstarLocationDetail
         <rubriklib_int.models.QstarLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('QstarLocationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_qstar_location(
            self, id, updated_definition, custom_headers=None, raw=False, **operation_config):
        """Update an Qstar archival location.

        Update the properties of a QStar archival location object.

        :param id: ID of the archival location.
        :type id: str
        :param updated_definition: Object containing information about the
         archival location.
        :type updated_definition: :class:`QstarLocationUpdate
         <rubriklib_int.models.QstarLocationUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`QstarLocationDetail
         <rubriklib_int.models.QstarLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`QstarLocationDetail
         <rubriklib_int.models.QstarLocationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/archive/qstar/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(updated_definition, 'QstarLocationUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('QstarLocationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_auth_domain(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of authentication domains.

        Get a list of authentication domains.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`AuthDomainSummary
         <rubriklib_int.models.AuthDomainSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`AuthDomainSummary
         <rubriklib_int.models.AuthDomainSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/auth_domain'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AuthDomainSummary]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_auth_domain(
            self, auth_domain_join_info, custom_headers=None, raw=False, **operation_config):
        """Add a new authentication domain.

        Add a new authentication domain. .

        :param auth_domain_join_info: Information for joining an
         authentication domain
        :type auth_domain_join_info: :class:`AuthDomainJoinInfo
         <rubriklib_int.models.AuthDomainJoinInfo>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AuthDomainSummary
         <rubriklib_int.models.AuthDomainSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AuthDomainSummary
         <rubriklib_int.models.AuthDomainSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/auth_domain'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(auth_domain_join_info, 'AuthDomainJoinInfo')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('AuthDomainSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_auth_domain(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a auth domain for the given id.

        Delete a auth domain for the given id.

        :param id: ID of the Auth Domain to be deleted
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/auth_domain/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def query_authorization(
            self, principals, custom_headers=None, raw=False, **operation_config):
        """Queries the current list of explicit authorizations.

        Queries the current list of explicit authorizations.

        :param principals: List of principals (ManagedIds) whose
         authorizations to query
        :type principals: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AuthorizationSummaryListResponse
         <rubriklib_int.models.AuthorizationSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AuthorizationSummaryListResponse
         <rubriklib_int.models.AuthorizationSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization'

        # Construct parameters
        query_parameters = {}
        query_parameters['principals'] = self._serialize.query("principals", principals, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AuthorizationSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def effective_authorizations_for_resources(
            self, effective_authorizations_query, custom_headers=None, raw=False, **operation_config):
        """Queries the current effective authorizations on the specified
        resources.

        Queries the current effective authorizations on the specified
        resources.

        :param effective_authorizations_query: Query listing all resources to
         get effective authorizations for
        :type effective_authorizations_query:
         :class:`EffectiveAuthorizationsQuery
         <rubriklib_int.models.EffectiveAuthorizationsQuery>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AuthorizationSummary
         <rubriklib_int.models.AuthorizationSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AuthorizationSummary
         <rubriklib_int.models.AuthorizationSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/effective/for_resources'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(effective_authorizations_query, 'EffectiveAuthorizationsQuery')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AuthorizationSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def effective_roles(
            self, principal=None, resource_types=None, custom_headers=None, raw=False, **operation_config):
        """Queries the current effective authorizations by role.

        Queries the current effective authorizations by role.

        :param principal: Optional principal (ManagedId) whose authorizations
         to query; if not specified, the current authenticated user will be
         used
        :type principal: str
        :param resource_types: Optional comma-separated list of resource
         types. If specified, only those roles and privileges are returned for
         which the principal has an authorization for at least one of the types
         in the list. Accepted values are:
        :type resource_types: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AuthorizationRoles
         <rubriklib_int.models.AuthorizationRoles>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AuthorizationRoles
         <rubriklib_int.models.AuthorizationRoles>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/effective/roles'

        # Construct parameters
        query_parameters = {}
        if principal is not None:
            query_parameters['principal'] = self._serialize.query("principal", principal, 'str')
        if resource_types is not None:
            query_parameters['resource_types'] = self._serialize.query("resource_types", resource_types, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AuthorizationRoles', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def revoke_authorization_admin(
            self, authorization_policy, custom_headers=None, raw=False, **operation_config):
        """Revokes an admin authorization for principal(s).

        Revokes an admin authorization for principal(s).

        :param authorization_policy: Policy describing the authorization to
         remove
        :type authorization_policy: :class:`BulkAdminAuthorization
         <rubriklib_int.models.BulkAdminAuthorization>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AdminAuthorizationListResponse
         <rubriklib_int.models.AdminAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AdminAuthorizationListResponse
         <rubriklib_int.models.AdminAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/role/admin'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(authorization_policy, 'BulkAdminAuthorization')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AdminAuthorizationListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_authorization_admin(
            self, principals, custom_headers=None, raw=False, **operation_config):
        """Gets the current list of explicit authorizations for the admin role.

        Gets the current list of explicit authorizations for the admin role.

        :param principals: List of principals (ManagedIds) whose explicit
         authorizations to get
        :type principals: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AdminAuthorizationListResponse
         <rubriklib_int.models.AdminAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AdminAuthorizationListResponse
         <rubriklib_int.models.AdminAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/role/admin'

        # Construct parameters
        query_parameters = {}
        query_parameters['principals'] = self._serialize.query("principals", principals, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AdminAuthorizationListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def grant_authorization_admin(
            self, authorization_policy, custom_headers=None, raw=False, **operation_config):
        """Grants an admin authorization for principal(s).

        Grants an admin authorization for principal(s).

        :param authorization_policy: Policy describing the authorization to
         add
        :type authorization_policy: :class:`BulkAdminAuthorization
         <rubriklib_int.models.BulkAdminAuthorization>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AdminAuthorizationListResponse
         <rubriklib_int.models.AdminAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AdminAuthorizationListResponse
         <rubriklib_int.models.AdminAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/role/admin'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(authorization_policy, 'BulkAdminAuthorization')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AdminAuthorizationListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def revoke_authorization_end_user(
            self, authorization_policy, custom_headers=None, raw=False, **operation_config):
        """Revokes an end_user authorization for principal(s).

        Revokes an end_user authorization for principal(s).

        :param authorization_policy: Policy describing the authorization to
         remove
        :type authorization_policy: :class:`BulkEndUserAuthorization
         <rubriklib_int.models.BulkEndUserAuthorization>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EndUserAuthorizationListResponse
         <rubriklib_int.models.EndUserAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EndUserAuthorizationListResponse
         <rubriklib_int.models.EndUserAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/role/end_user'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(authorization_policy, 'BulkEndUserAuthorization')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndUserAuthorizationListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_authorization_end_user(
            self, principals, custom_headers=None, raw=False, **operation_config):
        """Gets the current list of explicit authorizations for the end_user role.

        Gets the current list of explicit authorizations for the end_user role.

        :param principals: List of principals (ManagedIds) whose explicit
         authorizations to get
        :type principals: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EndUserAuthorizationListResponse
         <rubriklib_int.models.EndUserAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EndUserAuthorizationListResponse
         <rubriklib_int.models.EndUserAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/role/end_user'

        # Construct parameters
        query_parameters = {}
        query_parameters['principals'] = self._serialize.query("principals", principals, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndUserAuthorizationListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def grant_authorization_end_user(
            self, authorization_policy, custom_headers=None, raw=False, **operation_config):
        """Grants an end_user authorization for principal(s).

        Grants an end_user authorization for principal(s).

        :param authorization_policy: Policy describing the authorization to
         add
        :type authorization_policy: :class:`BulkEndUserAuthorization
         <rubriklib_int.models.BulkEndUserAuthorization>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EndUserAuthorizationListResponse
         <rubriklib_int.models.EndUserAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EndUserAuthorizationListResponse
         <rubriklib_int.models.EndUserAuthorizationListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/authorization/role/end_user'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(authorization_policy, 'BulkEndUserAuthorization')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndUserAuthorizationListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_public_cloud_machine_image(
            self, snappable_id=None, location_id=None, offset=None, limit=None, snappable_name=None, custom_headers=None, raw=False, **operation_config):
        """Query for a list of a cloud images.

        Query for a list of a cloud images.

        :param snappable_id: Filters cloud images by snappable ID
        :type snappable_id: str
        :param location_id: Filters cloud images by location ID
        :type location_id: str
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param limit: Limit the number of matches returned. Default is to
         return all available records.
        :type limit: int
        :param snappable_name: Filters results to images with source snappable
         names containing the given query.
        :type snappable_name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AwsImageSummaryListResponse
         <rubriklib_int.models.AwsImageSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AwsImageSummaryListResponse
         <rubriklib_int.models.AwsImageSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/image'

        # Construct parameters
        query_parameters = {}
        if snappable_id is not None:
            query_parameters['snappable_id'] = self._serialize.query("snappable_id", snappable_id, 'str')
        if location_id is not None:
            query_parameters['location_id'] = self._serialize.query("location_id", location_id, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if snappable_name is not None:
            query_parameters['snappable_name'] = self._serialize.query("snappable_name", snappable_name, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AwsImageSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_public_cloud_machine_image(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about a given cloud image.

        Get details about a given cloud image.

        :param id: ID of the cloud image
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AwsImageDetail <rubriklib_int.models.AwsImageDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AwsImageDetail <rubriklib_int.models.AwsImageDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/image/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AwsImageDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_public_cloud_machine_image(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a given cloud image.

        Delete a given cloud image.

        :param id: ID of the cloud instance
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/image/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_public_cloud_machine_instance(
            self, offset=None, limit=None, snappable_name=None, custom_headers=None, raw=False, **operation_config):
        """Query for a list of a cloud instances.

        Query for a list of a cloud instances.

        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param limit: Limit the number of matches returned. Default is to
         return all available records.
        :type limit: int
        :param snappable_name: Filters results to instances with source
         snappable names containing the given query.
        :type snappable_name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AwsInstanceSummaryListResponse
         <rubriklib_int.models.AwsInstanceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AwsInstanceSummaryListResponse
         <rubriklib_int.models.AwsInstanceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/instance'

        # Construct parameters
        query_parameters = {}
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if snappable_name is not None:
            query_parameters['snappable_name'] = self._serialize.query("snappable_name", snappable_name, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AwsInstanceSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_public_cloud_machine_instance(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Instantiate using the given snapshot on the given location.

        Instantiate using the given snapshot on the given location, creating a
        new cloud image if necessary.
        .

        :param request: Request to create a new public cloud instance.
        :type request: :class:`CreateCloudInstanceRequest
         <rubriklib_int.models.CreateCloudInstanceRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/instance'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'CreateCloudInstanceRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def switch_public_cloud_machine_instance_power(
            self, update, custom_headers=None, raw=False, **operation_config):
        """Turn on or off a given cloud instance.

        Turn on or off a given cloud instance.

        :param update: Properties to update
        :type update: :class:`CloudInstanceUpdate
         <rubriklib_int.models.CloudInstanceUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AwsInstanceDetail
         <rubriklib_int.models.AwsInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AwsInstanceDetail
         <rubriklib_int.models.AwsInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/instance'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'CloudInstanceUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AwsInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_public_cloud_machine_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about a given cloud instance.

        Get details about a given cloud instance.

        :param id: ID of the cloud instance
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AwsInstanceDetail
         <rubriklib_int.models.AwsInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AwsInstanceDetail
         <rubriklib_int.models.AwsInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AwsInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_public_cloud_machine_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a given cloud instance.

        Delete a given cloud instance.

        :param id: ID of the cloud instance
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_recommended_instance_type(
            self, snapshot_id, custom_headers=None, raw=False, **operation_config):
        """Get the recommended instance type for a given VMWare snapshot.

        Get the recommended instance type for a given VMWare snapshot.

        :param snapshot_id: snapshot ID
        :type snapshot_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RecommendedInstanceType
         <rubriklib_int.models.RecommendedInstanceType>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RecommendedInstanceType
         <rubriklib_int.models.RecommendedInstanceType>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/recommended_instance_type'

        # Construct parameters
        query_parameters = {}
        query_parameters['snapshot_id'] = self._serialize.query("snapshot_id", snapshot_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RecommendedInstanceType', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_aws_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get asynchronous request details for AWS-related jobs.

        Get the details of an asynchronous request that involves AWS.

        :param id: ID of an asynchronous request.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_security_group(
            self, data_location_id, vpc_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of security group IDs queried by VPC ID.

        :param data_location_id: data location ID
        :type data_location_id: str
        :param vpc_id: VPC ID
        :type vpc_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`SecurityGroup
         <rubriklib_int.models.SecurityGroup>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`SecurityGroup
         <rubriklib_int.models.SecurityGroup>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/security_group'

        # Construct parameters
        query_parameters = {}
        query_parameters['data_location_id'] = self._serialize.query("data_location_id", data_location_id, 'str')
        query_parameters['vpc_id'] = self._serialize.query("vpc_id", vpc_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[SecurityGroup]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_subnet(
            self, data_location_id, custom_headers=None, raw=False, **operation_config):
        """Get a list of subnets queried by location ID.

        :param data_location_id: data location ID
        :type data_location_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`Subnet <rubriklib_int.models.Subnet>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`Subnet <rubriklib_int.models.Subnet>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/aws/subnet'

        # Construct parameters
        query_parameters = {}
        query_parameters['data_location_id'] = self._serialize.query("data_location_id", data_location_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Subnet]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_blackout_window_status(
            self, custom_headers=None, raw=False, **operation_config):
        """Get current status of global blackout window.

        Determine whether global blackout window is currently active.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalBlackoutWindowStatus
         <rubriklib_int.models.GlobalBlackoutWindowStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalBlackoutWindowStatus
         <rubriklib_int.models.GlobalBlackoutWindowStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/blackout_window'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalBlackoutWindowStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def toggle_blackout_window(
            self, blackout_window_status, custom_headers=None, raw=False, **operation_config):
        """Starts or stops the global blackout window in local Rubrik cluster.

        Return whether we are in blackout window or not.

        :param blackout_window_status: Whether to start or stop the global
         blackout window.
        :type blackout_window_status: :class:`GlobalBlackoutWindowStatus
         <rubriklib_int.models.GlobalBlackoutWindowStatus>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalBlackoutWindowStatus
         <rubriklib_int.models.GlobalBlackoutWindowStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalBlackoutWindowStatus
         <rubriklib_int.models.GlobalBlackoutWindowStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/blackout_window'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(blackout_window_status, 'GlobalBlackoutWindowStatus')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalBlackoutWindowStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def browse_query(
            self, snapshot_id, path, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Lists all files and directories in a given path.

        Lists all files and directories in a given path.

        :param snapshot_id: ID of the Snapshot that is browsed
        :type snapshot_id: str
        :param path: The absolute path of the starting point for the directory
         listing.
        :type path: str
        :param offset: Starting position in the list of path entries contained
         in the query results, sorted by lexicographical order. The response
         includes the specified numbered entry and all higher numbered entries.
        :type offset: int
        :param limit: Maximum number of entries in the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/browse'

        # Construct parameters
        query_parameters = {}
        query_parameters['snapshot_id'] = self._serialize.query("snapshot_id", snapshot_id, 'str')
        query_parameters['path'] = self._serialize.query("path", path, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BrowseResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_config_status(
            self, request_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Cluster bootstrap request status.

        Retrieves status of in progress bootstrap requests.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param request_id: Id of the bootstrap request
        :type request_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterConfigStatus
         <rubriklib_int.models.ClusterConfigStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterConfigStatus
         <rubriklib_int.models.ClusterConfigStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/bootstrap'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['request_id'] = self._serialize.query("request_id", request_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterConfigStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bootstrap_cluster(
            self, cluster_config, id="me", custom_headers=None, raw=False, **operation_config):
        """Bootstrap the cluster.

        Issues a bootstrap request to a specified Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param cluster_config: Configuration for the Rubrik cluster
        :type cluster_config: :class:`ClusterConfig
         <rubriklib_int.models.ClusterConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeOperation <rubriklib_int.models.NodeOperation>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeOperation <rubriklib_int.models.NodeOperation>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/bootstrap'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(cluster_config, 'ClusterConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('NodeOperation', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_brik_count(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get cluster brik count.

        Retrieve the number of briks in this Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/brik_count'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def decommission_node_status_method(
            self, request_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Get decommission request status.

        Retrieves the status of the decommission node request.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param request_id: Decommission request id
        :type request_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DecommissionNodeStatus
         <rubriklib_int.models.DecommissionNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DecommissionNodeStatus
         <rubriklib_int.models.DecommissionNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/decommission_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['request_id'] = self._serialize.query("request_id", request_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DecommissionNodeStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def decommission_node(
            self, decommission_node_config, id="me", custom_headers=None, raw=False, **operation_config):
        """Decommission a node.

        Schedule a node for decommission.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param decommission_node_config: Decommission node configuration.
        :type decommission_node_config: :class:`DecommissionNodeConfig
         <rubriklib_int.models.DecommissionNodeConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeOperation <rubriklib_int.models.NodeOperation>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeOperation <rubriklib_int.models.NodeOperation>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/decommission_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(decommission_node_config, 'DecommissionNodeConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('NodeOperation', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def discover(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Discover bootstrappable nodes.

        Searches for nodes bootstrappable to the specified Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/discover'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_disks(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get disks.

        Retrieves information about the disks in the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`DiskInfo <rubriklib_int.models.DiskInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`DiskInfo <rubriklib_int.models.DiskInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/disk'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DiskInfo]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def setup_disk(
            self, disk_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Set up an unformatted disk.

        Formats, initializes and mounts an unformatted disk.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param disk_id: ID of an unformatted disk to set up
        :type disk_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DiskInfo <rubriklib_int.models.DiskInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DiskInfo <rubriklib_int.models.DiskInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/disk/{disk_id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'disk_id': self._serialize.url("disk_id", disk_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DiskInfo', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def remove_disk(
            self, disk_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Instruct the cluster that a disk has been removed.

        Marks the disk removed and updates cluster metadata.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param disk_id: ID of a missing disk to mark removed
        :type disk_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/disk/{disk_id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'disk_id': self._serialize.url("disk_id", disk_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_disk_capacity(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get installed disk capacity.

        Retrieves total installed disk space on the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DiskCapacity <rubriklib_int.models.DiskCapacity>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DiskCapacity <rubriklib_int.models.DiskCapacity>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/disk_capacity'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DiskCapacity', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_dns_nameservers(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get DNS servers.

        Retrieve a list the DNS servers assigned to the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/dns_nameserver'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def set_cluster_dns_nameservers(
            self, servers, id="me", custom_headers=None, raw=False, **operation_config):
        """Assign DNS servers.

        Assign DNS servers to the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param servers: List of the IPv4 addresses of NTP servers
        :type servers: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/dns_nameserver'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(servers, '[str]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_cluster_dns_search_domains(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get DNS search domains.

        Retrieve a list the DNS search domains assigned to the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/dns_search_domain'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def set_cluster_dns_search_domains(
            self, domains, id="me", custom_headers=None, raw=False, **operation_config):
        """Assign DNS search domains.

        Assign DNS search domains to the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param domains: List of the DNS search domains
        :type domains: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/dns_search_domain'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(domains, '[str]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_flash_capacity(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get installed flash capacity.

        Retrieves total installed flash on the Rubrik cluste .

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DiskCapacity <rubriklib_int.models.DiskCapacity>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DiskCapacity <rubriklib_int.models.DiskCapacity>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/flash_capacity'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DiskCapacity', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_floating_ip(
            self, id="me", floating_ip=None, custom_headers=None, raw=False, **operation_config):
        """Get a list of a cluster's floating IP to node mapping.

        Get a list of a cluster's floating IP to node mapping.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param floating_ip: Filter the result based on the floating_ip
         configured on the rubrik cluster.
         The query returns the node that owns this cluster IP address
        :type floating_ip: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FloatingIpListResponse
         <rubriklib_int.models.FloatingIpListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FloatingIpListResponse
         <rubriklib_int.models.FloatingIpListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/floating_ip'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if floating_ip is not None:
            query_parameters['floating_ip'] = self._serialize.query("floating_ip", floating_ip, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FloatingIpListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def has_tpm(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get if it has TPM.

        Check whether this Rubrik cluster has TPM.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/has_tpm'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_io(
            self, id="me", range=None, custom_headers=None, raw=False, **operation_config):
        """Get IO throughput information.

        Retrieves IO statistics of the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param range: Optional time range parameter for the timeseries, eg:
         -1h, -1min, etc. Default value is -6h
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`IoStat <rubriklib_int.models.IoStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`IoStat <rubriklib_int.models.IoStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/io_stats'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IoStat', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_ipmi(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get IPMI details.

        get IPMI details of availability and enabled access in the cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`IpmiDetails <rubriklib_int.models.IpmiDetails>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`IpmiDetails <rubriklib_int.models.IpmiDetails>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/ipmi'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IpmiDetails', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def modify_ipmi(
            self, update_properties, id="me", custom_headers=None, raw=False, **operation_config):
        """Modify IPMI settings.

        modify IPMI settings.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param update_properties: password to set
        :type update_properties: :class:`IpmiUpdate
         <rubriklib_int.models.IpmiUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`IpmiDetails <rubriklib_int.models.IpmiDetails>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`IpmiDetails <rubriklib_int.models.IpmiDetails>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/ipmi'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'IpmiUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IpmiDetails', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def is_encrypted(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get if it is encrypted.

        Check whether this Rubrik cluster is encrypted (the encryption could be
        either be software-based encryption or hardware-based encryption).

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/is_encrypted'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def is_hardware_encrypted(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get if it is hardware encrypted.

        Check whether this Rubrik cluster is hardware encrypted.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/is_hardware_encrypted'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def is_on_cloud(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get is on-cloud.

        Check whether this Rubrik cluster is running on cloud.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/is_on_cloud'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def is_registered_with_rubrik(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get registration status for a Rubrik cluster.

        Check whether the specified Rubrik cluster is registered in the Rubrik
        customer database.

        :param id: ID of a Rubrik cluster, or use *me* for the Rubrik cluster
         that is hosting the current session.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/is_registered'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def is_single_node(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get is single node.

        Check whether this Rubrik cluster is configured to be single node.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/is_single_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_iscsi(
            self, iscsi_portal_info, id="me", custom_headers=None, raw=False, **operation_config):
        """Add iscsi targets.

        Add iscsi targets from the specificied portal to the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param iscsi_portal_info: Iscsi target portal information
        :type iscsi_portal_info: :class:`IscsiAddParams
         <rubriklib_int.models.IscsiAddParams>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/iscsi'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(iscsi_portal_info, 'IscsiAddParams')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_memory_capacity(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get installed memory capacity.

        Retrieve total installed memory on the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`Capacity <rubriklib_int.models.Capacity>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`Capacity <rubriklib_int.models.Capacity>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/memory_capacity'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Capacity', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_name(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get cluster name.

        Retrieves the name of the Rubrik cluster identified by the id.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/name'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_nodes(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get nodes.

        Retrieve the list of nodes in this Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`NodeStatus <rubriklib_int.models.NodeStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`NodeStatus <rubriklib_int.models.NodeStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[NodeStatus]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_new_nodes(
            self, nodes, id="me", custom_headers=None, raw=False, **operation_config):
        """Add nodes.

        Add nodes to the specified Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param nodes: Mapping of Node name to IP configurations for the node
        :type nodes: dict
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeOperation <rubriklib_int.models.NodeOperation>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeOperation <rubriklib_int.models.NodeOperation>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(nodes, '{NodeConfig}')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('NodeOperation', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_ntp_servers(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get NTP Servers.

        Retrieve a list if the NTP servers assigned to the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/ntp_server'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def set_cluster_ntp_servers(
            self, servers, id="me", custom_headers=None, raw=False, **operation_config):
        """Assign NTP servers to Rubrik cluster.

        Assign NTP servers to Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param servers: List of fully qualifed domain names or IPv4 addresses
         of NTP servers
        :type servers: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/ntp_server'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(servers, '[str]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_add_node_status(
            self, request_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Get Add node request status.

        Retrieves status of a pending add node request on the specified
        cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param request_id: Request id of the add node request
        :type request_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AddNodesStatus <rubriklib_int.models.AddNodesStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AddNodesStatus <rubriklib_int.models.AddNodesStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/pending_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['request_id'] = self._serialize.query("request_id", request_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AddNodesStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def commission_request_status(
            self, request_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Get commission request status.

        Retrieves the status of the decommission node request.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param request_id: Recommission request id
        :type request_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RecommissionNodeStatus
         <rubriklib_int.models.RecommissionNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RecommissionNodeStatus
         <rubriklib_int.models.RecommissionNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/recommission_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['request_id'] = self._serialize.query("request_id", request_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RecommissionNodeStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def commission_node(
            self, node_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Recommission a node.

        Schedule a node for recommission.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param node_id: Id of the node to recommission
        :type node_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeOperation <rubriklib_int.models.NodeOperation>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeOperation <rubriklib_int.models.NodeOperation>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/recommission_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(node_id, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('NodeOperation', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def register_with_rubrik(
            self, community_user_credentials, id="me", custom_headers=None, raw=False, **operation_config):
        """Submit community user credentials to register a cluster.

        Submit community user credentials to register a cluster.

        :param id: ID of a Rubrik cluster, or use *me* for the Rubrik cluster
         that is hosting the current session.
        :type id: str
        :param community_user_credentials: Community User Credentials
        :type community_user_credentials: :class:`CommunityUserCredentials
         <rubriklib_int.models.CommunityUserCredentials>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/register'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(community_user_credentials, 'CommunityUserCredentials')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def process_registration_details(
            self, registration_details, id="me", custom_headers=None, raw=False, **operation_config):
        """Submit the registration details for a Rubrik cluster.

        Submit the registration details for the specified Rubrik cluster.

        :param id: ID of a Rubrik cluster, or use *me* for the Rubrik cluster
         that is hosting the current session.
        :type id: str
        :param registration_details: Registration details assigned to a Rubrik
         cluster
        :type registration_details: :class:`RegistrationDetails
         <rubriklib_int.models.RegistrationDetails>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/registration_details'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(registration_details, 'RegistrationDetails')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def remove_node_status_method(
            self, request_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Get node removal status.

        Retrieves the status of the remove node request.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param request_id: Remove node request id
        :type request_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RemoveNodeStatus
         <rubriklib_int.models.RemoveNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RemoveNodeStatus
         <rubriklib_int.models.RemoveNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/remove_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['request_id'] = self._serialize.query("request_id", request_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RemoveNodeStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def remove_node(
            self, node_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Removes a node from.

        Schedules a node for removal.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param node_id: Id of the node to remove
        :type node_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeOperation <rubriklib_int.models.NodeOperation>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeOperation <rubriklib_int.models.NodeOperation>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/remove_node'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(node_id, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NodeOperation', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reset_all_nodes(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Resets nodes in this Rubrik cluster.

        Resets nodes in this Rubrik cluster to manufactured state.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/reset'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def rotate_keys(
            self, key_rotation_options, id="me", custom_headers=None, raw=False, **operation_config):
        """Rotate keys in encrypted cluster.

        Trigger a key rotation for all nodes in the cluster. A reboot may be
        required depending on the rotation specification.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param key_rotation_options: Key rotation options
        :type key_rotation_options: :class:`KeyRotationOptions
         <rubriklib_int.models.KeyRotationOptions>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/key_rotation'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(key_rotation_options, 'KeyRotationOptions')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_key_rotation(
            self, id="me", rotation_id=None, custom_headers=None, raw=False, **operation_config):
        """Get details of key rotations.

        Return detailed information for a key rotation identified by
        **rotation_id**, or for all key rotations if **rotation_id** is not
        specified.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param rotation_id: ID of the key rotation or *latest* for the most
         recent key rotation.
        :type rotation_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`KeyRotationDetailListResponse
         <rubriklib_int.models.KeyRotationDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`KeyRotationDetailListResponse
         <rubriklib_int.models.KeyRotationDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/key_rotation'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if rotation_id is not None:
            query_parameters['rotation_id'] = self._serialize.query("rotation_id", rotation_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('KeyRotationDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_kmip_client_csr(
            self, csr_request, id="me", custom_headers=None, raw=False, **operation_config):
        """Generate a new private key and return a certificate signing request.

        Generates a new private key and return base64 encoded PKCS#10
        certificate signing request. If there is a pending CSR, this will
        invalidate it and create a new one.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param csr_request: Information for client certificate request
        :type csr_request: :class:`KmipCsrRequest
         <rubriklib_int.models.KmipCsrRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`Pkcs10CertificateSigningRequest
         <rubriklib_int.models.Pkcs10CertificateSigningRequest>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`Pkcs10CertificateSigningRequest
         <rubriklib_int.models.Pkcs10CertificateSigningRequest>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/kmip/client_csr'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(csr_request, 'KmipCsrRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Pkcs10CertificateSigningRequest', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def set_kmip_configuration(
            self, config, id="me", custom_headers=None, raw=False, **operation_config):
        """Configure KMIP server to use.

        Configure each node with the specified KMIP configuration.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param config: KMIP configuration
        :type config: :class:`KmipConfiguration
         <rubriklib_int.models.KmipConfiguration>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/kmip/configuration'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'KmipConfiguration')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_kmip_configuration(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get KMIP configuration.

        Return the currently configured KMIP information. If KMIP is not
        configured, the return object would contain empty fields.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`KmipConfigurationDetail
         <rubriklib_int.models.KmipConfigurationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`KmipConfigurationDetail
         <rubriklib_int.models.KmipConfigurationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/kmip/configuration'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('KmipConfigurationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_async_request_status(
            self, request_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Get details about an async request.

        Get details about a security-related async request.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param request_id: ID of the request
        :type request_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/request/{request_id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'request_id': self._serialize.url("request_id", request_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_web_csr(
            self, csr_request, id="me", custom_headers=None, raw=False, **operation_config):
        """Generate a new private key and return a certificate signing request.

        Generates a new private key and return base64 encoded PKCS#10
        certificate signing request. If there is a pending CSR, this will
        invalidate it and create a new one.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param csr_request: Information for client certificate request
        :type csr_request: :class:`WebCsrRequest
         <rubriklib_int.models.WebCsrRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`Pkcs10CertificateSigningRequest
         <rubriklib_int.models.Pkcs10CertificateSigningRequest>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`Pkcs10CertificateSigningRequest
         <rubriklib_int.models.Pkcs10CertificateSigningRequest>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/web_csr'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(csr_request, 'WebCsrRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Pkcs10CertificateSigningRequest', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def set_web_signed_certificate(
            self, certificate, id="me", custom_headers=None, raw=False, **operation_config):
        """Set a signed certificate for Web server.

        Setting the given certificate for each node's web server to use.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param certificate: X.509 certificate
        :type certificate: :class:`X509Certificate
         <rubriklib_int.models.X509Certificate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/security/web_signed_cert'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(certificate, 'X509Certificate')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_timezone(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get existing cluster timezone settings.

        Get existing cluster timezone settings. An empty timezone means that
        the timezone for this cluster is not set yet and we use UTC as the
        deafult timezone in that case.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterTimezone
         <rubriklib_int.models.ClusterTimezone>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterTimezone
         <rubriklib_int.models.ClusterTimezone>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/timezone'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterTimezone', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_cluster_timezone(
            self, cluster_timezone, id="me", custom_headers=None, raw=False, **operation_config):
        """Update cluster timezone settings.

        Update cluster timezone settings.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param cluster_timezone: Cluster timezone settings
        :type cluster_timezone: :class:`ClusterTimezone
         <rubriklib_int.models.ClusterTimezone>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterTimezone
         <rubriklib_int.models.ClusterTimezone>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterTimezone
         <rubriklib_int.models.ClusterTimezone>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/timezone'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(cluster_timezone, 'ClusterTimezone')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterTimezone', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def configure_vlan(
            self, vlan_info, id="me", custom_headers=None, raw=False, **operation_config):
        """Adds a VLAN interface on the cluster or re-ips a VLAN.

        Edits tagged interfaces on the cluster by VLAN.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param vlan_info: VLAN Configuration
        :type vlan_info: :class:`VlanConfig <rubriklib_int.models.VlanConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/vlan'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(vlan_info, 'VlanConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_vlan(
            self, vlan_id, id="me", custom_headers=None, raw=False, **operation_config):
        """Drops a VLAN from the cluster.

        Drops interfaces assigend to the specified VLAN on the cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param vlan_id: VLAN
        :type vlan_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/vlan'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['vlan_id'] = self._serialize.query("vlan_id", vlan_id, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_vlan(
            self, id="me", vlan=None, custom_headers=None, raw=False, **operation_config):
        """Get configured VLAN interfaces for a Rubrik Cluster cluster.

        Retrieves the VLANs configured on a Rubrik Cluster and their ip
        configurations.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param vlan: Will retrieve info for a specific VLAN if passed in
        :type vlan: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`VlanConfig <rubriklib_int.models.VlanConfig>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`VlanConfig <rubriklib_int.models.VlanConfig>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/cluster/{id}/vlan'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if vlan is not None:
            query_parameters['vlan'] = self._serialize.query("vlan", vlan, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[VlanConfig]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_atlas_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Atlas configuration.

        REQUIRES SUPPORT TOKEN - Get the global Atlas configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalAtlasConfig
         <rubriklib_int.models.GlobalAtlasConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalAtlasConfig
         <rubriklib_int.models.GlobalAtlasConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/atlas'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalAtlasConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_atlas_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Atlas configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Atlas configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalAtlasConfig
         <rubriklib_int.models.GlobalAtlasConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalAtlasConfig
         <rubriklib_int.models.GlobalAtlasConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalAtlasConfig
         <rubriklib_int.models.GlobalAtlasConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/atlas'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalAtlasConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalAtlasConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_blobstore_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Blobstore configuration.

        REQUIRES SUPPORT TOKEN - Get the global Blobstore configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalBlobstoreConfig
         <rubriklib_int.models.GlobalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalBlobstoreConfig
         <rubriklib_int.models.GlobalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/blobstore'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalBlobstoreConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_blobstore_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Blobstore configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Blobstore configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalBlobstoreConfig
         <rubriklib_int.models.GlobalBlobstoreConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalBlobstoreConfig
         <rubriklib_int.models.GlobalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalBlobstoreConfig
         <rubriklib_int.models.GlobalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/blobstore'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalBlobstoreConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalBlobstoreConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cerebro_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Cerebro configuration.

        REQUIRES SUPPORT TOKEN - Get the global Cerebro configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalCerebroConfig
         <rubriklib_int.models.GlobalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalCerebroConfig
         <rubriklib_int.models.GlobalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/cerebro'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalCerebroConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_cerebro_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Cerebro configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Cerebro configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalCerebroConfig
         <rubriklib_int.models.GlobalCerebroConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalCerebroConfig
         <rubriklib_int.models.GlobalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalCerebroConfig
         <rubriklib_int.models.GlobalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/cerebro'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalCerebroConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalCerebroConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_crystal_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Crystal configuration.

        REQUIRES SUPPORT TOKEN - Get the global Crystal configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalCrystalConfig
         <rubriklib_int.models.GlobalCrystalConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalCrystalConfig
         <rubriklib_int.models.GlobalCrystalConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/crystal'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalCrystalConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_crystal_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Crystal configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Crystal configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalCrystalConfig
         <rubriklib_int.models.GlobalCrystalConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalCrystalConfig
         <rubriklib_int.models.GlobalCrystalConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalCrystalConfig
         <rubriklib_int.models.GlobalCrystalConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/crystal'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalCrystalConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalCrystalConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_fileset_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Fileset configuration.

        REQUIRES SUPPORT TOKEN - Get the global Fileset configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalFilesetConfig
         <rubriklib_int.models.GlobalFilesetConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalFilesetConfig
         <rubriklib_int.models.GlobalFilesetConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/fileset'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalFilesetConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_fileset_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Fileset configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Fileset configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalFilesetConfig
         <rubriklib_int.models.GlobalFilesetConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalFilesetConfig
         <rubriklib_int.models.GlobalFilesetConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalFilesetConfig
         <rubriklib_int.models.GlobalFilesetConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/fileset'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalFilesetConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalFilesetConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_forge_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Forge configuration.

        REQUIRES SUPPORT TOKEN - Get the global Forge configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalForgeConfig
         <rubriklib_int.models.GlobalForgeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalForgeConfig
         <rubriklib_int.models.GlobalForgeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/forge'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalForgeConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_forge_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Forge configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Forge configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalForgeConfig
         <rubriklib_int.models.GlobalForgeConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalForgeConfig
         <rubriklib_int.models.GlobalForgeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalForgeConfig
         <rubriklib_int.models.GlobalForgeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/forge'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalForgeConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalForgeConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_infinity_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Infinity configuration.

        REQUIRES SUPPORT TOKEN - Get the global Infinity configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalInfinityConfig
         <rubriklib_int.models.GlobalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalInfinityConfig
         <rubriklib_int.models.GlobalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/infinity'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalInfinityConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_infinity_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Infinity configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Infinity configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalInfinityConfig
         <rubriklib_int.models.GlobalInfinityConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalInfinityConfig
         <rubriklib_int.models.GlobalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalInfinityConfig
         <rubriklib_int.models.GlobalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/infinity'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalInfinityConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalInfinityConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_jarvis_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Jarvis configuration.

        REQUIRES SUPPORT TOKEN - Get the global Jarvis configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalJarvisConfig
         <rubriklib_int.models.GlobalJarvisConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalJarvisConfig
         <rubriklib_int.models.GlobalJarvisConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/jarvis'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalJarvisConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_jarvis_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Jarvis configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Jarvis configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalJarvisConfig
         <rubriklib_int.models.GlobalJarvisConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalJarvisConfig
         <rubriklib_int.models.GlobalJarvisConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalJarvisConfig
         <rubriklib_int.models.GlobalJarvisConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/jarvis'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalJarvisConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalJarvisConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_local_blobstore_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the local Blobstore configuration.

        REQUIRES SUPPORT TOKEN - Get the local Blobstore configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalBlobstoreConfig
         <rubriklib_int.models.LocalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalBlobstoreConfig
         <rubriklib_int.models.LocalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_blobstore'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalBlobstoreConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_local_blobstore_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the local Blobstore configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the local Blobstore configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`LocalBlobstoreConfig
         <rubriklib_int.models.LocalBlobstoreConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalBlobstoreConfig
         <rubriklib_int.models.LocalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalBlobstoreConfig
         <rubriklib_int.models.LocalBlobstoreConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_blobstore'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'LocalBlobstoreConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalBlobstoreConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_local_cerebro_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the local Cerebro configuration.

        REQUIRES SUPPORT TOKEN - Get the local Cerebro configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalCerebroConfig
         <rubriklib_int.models.LocalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalCerebroConfig
         <rubriklib_int.models.LocalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_cerebro'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalCerebroConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_local_cerebro_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the local Cerebro configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the local Cerebro configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`LocalCerebroConfig
         <rubriklib_int.models.LocalCerebroConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalCerebroConfig
         <rubriklib_int.models.LocalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalCerebroConfig
         <rubriklib_int.models.LocalCerebroConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_cerebro'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'LocalCerebroConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalCerebroConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_local_infinity_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the local Infinity configuration.

        REQUIRES SUPPORT TOKEN - Get the local Infinity configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalInfinityConfig
         <rubriklib_int.models.LocalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalInfinityConfig
         <rubriklib_int.models.LocalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_infinity'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalInfinityConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_local_infinity_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the local Infinity configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the local Infinity configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`LocalInfinityConfig
         <rubriklib_int.models.LocalInfinityConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalInfinityConfig
         <rubriklib_int.models.LocalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalInfinityConfig
         <rubriklib_int.models.LocalInfinityConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_infinity'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'LocalInfinityConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalInfinityConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_local_mssql_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the local Mssql configuration.

        REQUIRES SUPPORT TOKEN - Get the local Mssql configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalMssqlConfig
         <rubriklib_int.models.LocalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalMssqlConfig
         <rubriklib_int.models.LocalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_mssql'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalMssqlConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_local_mssql_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the local Mssql configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the local Mssql configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`LocalMssqlConfig
         <rubriklib_int.models.LocalMssqlConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalMssqlConfig
         <rubriklib_int.models.LocalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalMssqlConfig
         <rubriklib_int.models.LocalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_mssql'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'LocalMssqlConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalMssqlConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_local_shield_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the local Shield configuration.

        REQUIRES SUPPORT TOKEN - Get the local Shield configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalShieldConfig
         <rubriklib_int.models.LocalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalShieldConfig
         <rubriklib_int.models.LocalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_shield'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalShieldConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_local_shield_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the local Shield configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the local Shield configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`LocalShieldConfig
         <rubriklib_int.models.LocalShieldConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalShieldConfig
         <rubriklib_int.models.LocalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalShieldConfig
         <rubriklib_int.models.LocalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_shield'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'LocalShieldConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalShieldConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_local_thor_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the local Thor configuration.

        REQUIRES SUPPORT TOKEN - Get the local Thor configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalThorConfig
         <rubriklib_int.models.LocalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalThorConfig
         <rubriklib_int.models.LocalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_thor'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalThorConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_local_thor_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the local Thor configuration. A support
        token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the local Thor configuration. A support
        token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`LocalThorConfig
         <rubriklib_int.models.LocalThorConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`LocalThorConfig
         <rubriklib_int.models.LocalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`LocalThorConfig
         <rubriklib_int.models.LocalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/local_thor'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'LocalThorConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LocalThorConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_managed_volume_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Managedvolume configuration.

        REQUIRES SUPPORT TOKEN - Get the global Managedvolume configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalManagedVolumeConfig
         <rubriklib_int.models.GlobalManagedVolumeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalManagedVolumeConfig
         <rubriklib_int.models.GlobalManagedVolumeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/managedVolume'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalManagedVolumeConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_managed_volume_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Managedvolume configuration.
        A support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Managedvolume configuration.
        A support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalManagedVolumeConfig
         <rubriklib_int.models.GlobalManagedVolumeConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalManagedVolumeConfig
         <rubriklib_int.models.GlobalManagedVolumeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalManagedVolumeConfig
         <rubriklib_int.models.GlobalManagedVolumeConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/managedVolume'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalManagedVolumeConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalManagedVolumeConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Mssql configuration.

        REQUIRES SUPPORT TOKEN - Get the global Mssql configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalMssqlConfig
         <rubriklib_int.models.GlobalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalMssqlConfig
         <rubriklib_int.models.GlobalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/mssql'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalMssqlConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_mssql_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Mssql configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Mssql configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalMssqlConfig
         <rubriklib_int.models.GlobalMssqlConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalMssqlConfig
         <rubriklib_int.models.GlobalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalMssqlConfig
         <rubriklib_int.models.GlobalMssqlConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/mssql'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalMssqlConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalMssqlConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_shield_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Shield configuration.

        REQUIRES SUPPORT TOKEN - Get the global Shield configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalShieldConfig
         <rubriklib_int.models.GlobalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalShieldConfig
         <rubriklib_int.models.GlobalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/shield'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalShieldConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_shield_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Shield configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Shield configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalShieldConfig
         <rubriklib_int.models.GlobalShieldConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalShieldConfig
         <rubriklib_int.models.GlobalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalShieldConfig
         <rubriklib_int.models.GlobalShieldConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/shield'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalShieldConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalShieldConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_snapshot_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Snapshot configuration.

        REQUIRES SUPPORT TOKEN - Get the global Snapshot configuration. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalSnapshotConfig
         <rubriklib_int.models.GlobalSnapshotConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalSnapshotConfig
         <rubriklib_int.models.GlobalSnapshotConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/snapshot'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalSnapshotConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_snapshot_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Snapshot configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Snapshot configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalSnapshotConfig
         <rubriklib_int.models.GlobalSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalSnapshotConfig
         <rubriklib_int.models.GlobalSnapshotConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalSnapshotConfig
         <rubriklib_int.models.GlobalSnapshotConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/snapshot'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalSnapshotConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalSnapshotConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_thor_config(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Get the global Thor configuration.

        REQUIRES SUPPORT TOKEN - Get the global Thor configuration. A support
        token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalThorConfig
         <rubriklib_int.models.GlobalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalThorConfig
         <rubriklib_int.models.GlobalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/thor'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalThorConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_thor_config(
            self, new_values, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Update the global Thor configuration. A
        support token is required for this operation.

        REQUIRES SUPPORT TOKEN - Update the global Thor configuration. A
        support token is required for this operation.

        :param new_values: New configuration values
        :type new_values: :class:`GlobalThorConfig
         <rubriklib_int.models.GlobalThorConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GlobalThorConfig
         <rubriklib_int.models.GlobalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GlobalThorConfig
         <rubriklib_int.models.GlobalThorConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/config/thor'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_values, 'GlobalThorConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GlobalThorConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def clean_nfs_bucket(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Tries to clean up the data in the bucket in
        the NFS spec.

        REQUIRES SUPPORT TOKEN - To be used by internal tests to clean the
        buckets. A support token is required for this operation.

        :param definition: Data Location definition
        :type definition: :class:`NfsLocationDefinition
         <rubriklib_int.models.NfsLocationDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/nfs'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'NfsLocationDefinition')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def remove_nfs_bucket(
            self, request, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Remove all buckets matching given prefix.

        REQUIRES SUPPORT TOKEN - To be used by internal tests to remove all nfs
        buckets matching given prefix. Returns a list of buckets successfully
        removed. A support token is required for this operation.

        :param request: Remove bucket request configurations
        :type request: :class:`RemoveNfsBucketRequest
         <rubriklib_int.models.RemoveNfsBucketRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/nfs/remove_bucket'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'RemoveNfsBucketRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def clean_object_store_bucket(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Tries to clean up the data in the bucket in
        the ObjectSTore spec.

        REQUIRES SUPPORT TOKEN - To be used by internal tests to clean the
        buckets. A support token is required for this operation.

        :param definition: Data Location definition
        :type definition: :class:`ObjectStoreLocationDefinition
         <rubriklib_int.models.ObjectStoreLocationDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/object_store'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'ObjectStoreLocationDefinition')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def remove_object_store_bucket(
            self, request, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Remove all buckets matching given prefix.

        REQUIRES SUPPORT TOKEN - To be used by internal tests to remove all
        object store buckets matching given prefix. Returns a list of buckets
        successfully removed. A support token is required for this operation.

        :param request: Remove bucket request configurations
        :type request: :class:`RemoveObjectStoreBucketRequest
         <rubriklib_int.models.RemoveObjectStoreBucketRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/object_store/remove_bucket'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'RemoveObjectStoreBucketRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def recover_archived_metadata(
            self, request, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - DataLocationId from which to start the
        recovery process.

        REQUIRES SUPPORT TOKEN - DataLocationId from which to start the
        recovery process. A support token is required for this operation.

        :param request: ID of the data location to recover from
        :type request: :class:`RecoverArchivedMetadataRequest
         <rubriklib_int.models.RecoverArchivedMetadataRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RecoverArchivedMetadataResponse
         <rubriklib_int.models.RecoverArchivedMetadataResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RecoverArchivedMetadataResponse
         <rubriklib_int.models.RecoverArchivedMetadataResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/recover_archived_metadata'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'RecoverArchivedMetadataRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RecoverArchivedMetadataResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_delete_replication_source_jobs(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Get the details of all one-off delete
        replication source jobs.

        REQUIRES SUPPORT TOKEN - Get the details of all one-off delete
        replication source jobs. A support token is required for this
        operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DeleteReplicationSourceJobListResponse
         <rubriklib_int.models.DeleteReplicationSourceJobListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DeleteReplicationSourceJobListResponse
         <rubriklib_int.models.DeleteReplicationSourceJobListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/replication_source/delete_job'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DeleteReplicationSourceJobListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def teardown(
            self, request, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  Disconnect from a specific data location.
        Deletes the lock files, encryption files, and all the data.

        REQUIRES SUPPORT TOKEN - Disconnect from a specific data location.
        Deletes the lock files, encryption files and all the data. A support
        token is required for this operation.

        :param request: dataLocationId
        :type request: :class:`DataLocationTeardownRequest
         <rubriklib_int.models.DataLocationTeardownRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DataLocationEndpointStatus
         <rubriklib_int.models.DataLocationEndpointStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DataLocationEndpointStatus
         <rubriklib_int.models.DataLocationEndpointStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/data_location/teardown'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'DataLocationTeardownRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DataLocationEndpointStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_events(
            self, limit=None, after_id=None, event_series_id=None, status=None, event_type=None, object_ids=None, before_date=None, after_date=None, object_type=None, custom_headers=None, raw=False, **operation_config):
        """Get information for specified events.

        Retrieve information for the latest of related events that match the
        value specified in any of the following categories: type, status, or
        ID, and limit events by date.

        :param limit: Maximum number of events retrieved
        :type limit: int
        :param after_id: Earliest event retrieved
        :type after_id: str
        :param event_series_id: Filter by Event Series ID (event_series_id)
        :type event_series_id: str
        :param status: Filter by Status. Enter any of the following values:
         'Failure', 'Warning', 'Running', 'Success', 'Canceled', 'Canceling.
        :type status: str
        :param event_type: Filter by Event Type. Possible values include:
         'Archive', 'Audit', 'Backup', 'Configuration', 'Diagnostic',
         'NutanixCluster', 'Recovery', 'Replication', 'VCenter'
        :type event_type: str
        :param object_ids: Filter by a comma separated list of object IDs.
        :type object_ids: list of str
        :param before_date: Filter all the events before a date.
        :type before_date: datetime
        :param after_date: Filter all the events after a date.
        :type after_date: datetime
        :param object_type: Filter all the events by object type. Enter any of
         the following values: 'VmwareVm', 'Mssql', 'LinuxFileset',
         'WindowsFileset', and 'NutanixVm'.
        :type object_type: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`EventSummary
         <rubriklib_int.models.EventSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`EventSummary
         <rubriklib_int.models.EventSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/event'

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if after_id is not None:
            query_parameters['after_id'] = self._serialize.query("after_id", after_id, 'str')
        if event_series_id is not None:
            query_parameters['event_series_id'] = self._serialize.query("event_series_id", event_series_id, 'str')
        if status is not None:
            query_parameters['status'] = self._serialize.query("status", status, 'str')
        if event_type is not None:
            query_parameters['event_type'] = self._serialize.query("event_type", event_type, 'str')
        if object_ids is not None:
            query_parameters['object_ids'] = self._serialize.query("object_ids", object_ids, '[str]', div=',')
        if before_date is not None:
            query_parameters['before_date'] = self._serialize.query("before_date", before_date, 'iso-8601')
        if after_date is not None:
            query_parameters['after_date'] = self._serialize.query("after_date", after_date, 'iso-8601')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EventSummary]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_event_status(
            self, ids, custom_headers=None, raw=False, **operation_config):
        """Get information for several events.

        Use the event series IDs of several events to retrieve information
        about each event, including ID, progress, cancelable, cancel pending,
        and the number of times the event has been attempted. Place each
        event_series_id on a separate line.

        :param ids: Event series IDs (event_series_id) of the event
        :type ids: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EventStatusSummaryListResponse
         <rubriklib_int.models.EventStatusSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EventStatusSummaryListResponse
         <rubriklib_int.models.EventStatusSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/event_series/status'

        # Construct parameters
        query_parameters = {}
        query_parameters['ids'] = self._serialize.query("ids", ids, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EventStatusSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_by_series_id(
            self, id, limit=None, after_id=None, custom_headers=None, raw=False, **operation_config):
        """Get events associated with an event series.

        Get events associated with an event series (a grouping of related
        events).

        :param id: The id of the event series
        :type id: str
        :param limit: Limits the number of events returned.
        :type limit: int
        :param after_id: Fetches all events after given id.
        :type after_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`EventSeriesSummary
         <rubriklib_int.models.EventSeriesSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`EventSeriesSummary
         <rubriklib_int.models.EventSeriesSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/event_series/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if after_id is not None:
            query_parameters['after_id'] = self._serialize.query("after_id", after_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EventSeriesSummary]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def cancel(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Cancel an event.

        Request cancelation of an event. To succeed, the 'isCancelable'
        parameter of the event must be 'true'.

        :param id: The Event Series ID (event_series_id) of the event
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/event_series/{id}/cancel'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def event_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information for a specific event.

        Use the event series ID for an event to retrieve information about the
        event, including ID, progress, cancelable, cancel pending, and the
        number of times the event has been attempted.

        :param id: Event series ID (event_series_id) of the event
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EventStatusSummary
         <rubriklib_int.models.EventStatusSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EventStatusSummary
         <rubriklib_int.models.EventStatusSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/event_series/{id}/status'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EventStatusSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_create_fileset(
            self, definitions, custom_headers=None, raw=False, **operation_config):
        """Create filesets for a host.

        Create filesets for a network host. Each fileset is a fileset template
        applied to a host.

        :param definitions: Specify an array of host and template ids
        :type definitions: list of :class:`FilesetCreate
         <rubriklib_int.models.FilesetCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetDetailListResponse
         <rubriklib_int.models.FilesetDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetDetailListResponse
         <rubriklib_int.models.FilesetDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/fileset/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definitions, '[FilesetCreate]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('FilesetDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_delete_fileset(
            self, ids, preserve_snapshots=None, custom_headers=None, raw=False, **operation_config):
        """Delete filesets.

        Delete filesets by specifying the fileset IDs.

        :param ids: Provide a comma-separated list of fileset IDs.
        :type ids: list of str
        :param preserve_snapshots: Flag to indicate whether to convert
         snapshots of all deleted filesets to relics or to delete them. Applies
         to all filesets. Default is true.
        :type preserve_snapshots: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/fileset/bulk'

        # Construct parameters
        query_parameters = {}
        query_parameters['ids'] = self._serialize.query("ids", ids, '[str]', div=',')
        if preserve_snapshots is not None:
            query_parameters['preserve_snapshots'] = self._serialize.query("preserve_snapshots", preserve_snapshots, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 404]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def create_fileset_restore_files_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Create restore job to restore multiple files/directories.

        Initiate a job to copy one or more file or folder from a fileset backup
        to the source host. Returns the job instance ID.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for job to restore one or more files or
         folders from a fileset backup.
        :type config: :class:`FilesetRestoreFilesJobConfig
         <rubriklib_int.models.FilesetRestoreFilesJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/fileset/snapshot/{id}/restore_files'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'FilesetRestoreFilesJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_create_fileset_template(
            self, definitions, custom_headers=None, raw=False, **operation_config):
        """Create fileset templates.

        Create fileset templates. The template is applied to the host.  Each
        template is a set of paths on the host.
        A template uses full paths and wildcards to define the objects to
        include, exclude, and exempt from exclusion.
        The **_exceptions_** value specifies paths that should not be excluded
        from the fileset by the **_exclude_** value.
        Specify an array of full path descriptions for each property
        **_include_**, **_exclude_**, and **_exceptions_**.
        Acceptable wildcard characters are
        + **_\*_** Single asterisk matches zero or more characters up to a path
        deliminator
        + **_\*\*_** Double asterisk matches zero or more characters
        The following rules apply to path descriptions
        + Accepts UTF-8 characters
        + Case sensitive
        + Forward slash character **_/_** is the path deliminator
        + Symbolic links must point to a subset of a non symbolic link path
        + Paths that do not start with **_/_** are modified to start with
        **_\*\*/_**
        + Paths that do not end with **_\*_** are modified to end with
        **_/\*\*_**.

        :param definitions: Provide an array containing a separate object for
         each fileset template definition.
        :type definitions: list of :class:`FilesetTemplateCreate
         <rubriklib_int.models.FilesetTemplateCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetTemplateDetailListResponse
         <rubriklib_int.models.FilesetTemplateDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetTemplateDetailListResponse
         <rubriklib_int.models.FilesetTemplateDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/fileset_template/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definitions, '[FilesetTemplateCreate]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('FilesetTemplateDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_update_fileset_template(
            self, definitions, custom_headers=None, raw=False, **operation_config):
        """Modify fileset templates.

        Modify the values of specified fileset templates.

        :param definitions: Provide an array containing a separate object for
         each fileset template being modified.
        :type definitions: list of :class:`FilesetTemplatePatch
         <rubriklib_int.models.FilesetTemplatePatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetTemplateDetailListResponse
         <rubriklib_int.models.FilesetTemplateDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetTemplateDetailListResponse
         <rubriklib_int.models.FilesetTemplateDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/fileset_template/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definitions, '[FilesetTemplatePatch]')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetTemplateDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_delete_fileset_template(
            self, ids, preserve_snapshots=None, custom_headers=None, raw=False, **operation_config):
        """Delete fileset templates.

        Deletes specfied fileset templates. Detaches and retains all associated
        filesets as independent filesets with the existing values.

        :param ids: Provide an array with the ID of each fileset template to
         remove.
        :type ids: list of str
        :param preserve_snapshots: Flag to indicate whether to convert
         snapshots of filesets of the deleted templates to relics or to delete
         them. Applies to all templates being deleted. Default is true.
        :type preserve_snapshots: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/fileset_template/bulk'

        # Construct parameters
        query_parameters = {}
        query_parameters['ids'] = self._serialize.query("ids", ids, '[str]', div=',')
        if preserve_snapshots is not None:
            query_parameters['preserve_snapshots'] = self._serialize.query("preserve_snapshots", preserve_snapshots, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 404]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_folder_hierarchy(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Hierarchy of folders and managed objects with this folder as root.

        Hierarchy of folders and managed objects with this folder as root.

        :param id: ID of the folder at the root of expected hierarchy.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FolderHierarchy
         <rubriklib_int.models.FolderHierarchy>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FolderHierarchy
         <rubriklib_int.models.FolderHierarchy>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/folder/hierarchy_rooted_at/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FolderHierarchy', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_host_folder(
            self, datacenter_id, custom_headers=None, raw=False, **operation_config):
        """Get the top level host folder.

        The top level host folder.

        :param datacenter_id: ID of the datacenter
        :type datacenter_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FolderDetail <rubriklib_int.models.FolderDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FolderDetail <rubriklib_int.models.FolderDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/folder/host/{datacenter_id}'
        path_format_arguments = {
            'datacenter_id': self._serialize.url("datacenter_id", datacenter_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FolderDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_vm_folder(
            self, datacenter_id, custom_headers=None, raw=False, **operation_config):
        """Get the top level vm folder.

        The top level vm folder.

        :param datacenter_id: ID of the datacenter
        :type datacenter_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FolderDetail <rubriklib_int.models.FolderDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FolderDetail <rubriklib_int.models.FolderDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/folder/vm/{datacenter_id}'
        path_format_arguments = {
            'datacenter_id': self._serialize.url("datacenter_id", datacenter_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FolderDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_folder(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Details of a folder.

        Details of a folder.

        :param id: ID of the Folder
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FolderDetail <rubriklib_int.models.FolderDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FolderDetail <rubriklib_int.models.FolderDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/folder/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FolderDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hierarchy_object(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary of a hierarchy object.

        Retrieve details for the specified storage hierarchy object.

        :param id: ID of the hierarchy object
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedHierarchyObjectSummary
         <rubriklib_int.models.ManagedHierarchyObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedHierarchyObjectSummary
         <rubriklib_int.models.ManagedHierarchyObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hierarchy/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedHierarchyObjectSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hierarchy_sla_conflicts(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get list of descendant objects with SLA conflicts.

        Retrieve the list of descendant objects with an explicitly configured
        SLA, or inherit an SLA from a different parent.

        :param id: ID of the hierarchy object
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedHierarchyObjectSummaryListResponse
         <rubriklib_int.models.ManagedHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedHierarchyObjectSummaryListResponse
         <rubriklib_int.models.ManagedHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hierarchy/{id}/sla_conflicts'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedHierarchyObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_register_host(
            self, hosts, custom_headers=None, raw=False, **operation_config):
        """Register hosts.

        Register hosts with Rubrik clusters.

        :param hosts: Array containing a registration definition for each
         host.
        :type hosts: list of :class:`HostRegister
         <rubriklib_int.models.HostRegister>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostDetailListResponse
         <rubriklib_int.models.HostDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostDetailListResponse
         <rubriklib_int.models.HostDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(hosts, '[HostRegister]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('HostDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_delete_host(
            self, ids, custom_headers=None, raw=False, **operation_config):
        """Deregister hosts.

        Deregister specified network hosts from Rubrik clusters.

        :param ids: Provide the ID of each host to deregister.
        :type ids: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/bulk-delete'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(ids, '[str]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def count_host(
            self, operating_system_type=None, share_type=None, custom_headers=None, raw=False, **operation_config):
        """Count all hosts.

        Retrieve the total number of hosts, and the total number of protected
        hosts. A protected host has at least one protected fileset.

        :param operating_system_type: Filter the summary information based on
         the operating system type. Values are 'Linux', 'Windows', 'ANY', or
         'NONE'.
         Use **_ANY_** to return the total number of hosts that have any
         operating system type set.
         Use **_NONE_** to return the total number of hosts that do not have
         operating system type set. Possible values include: 'Linux',
         'Windows', 'ANY', 'NONE'
        :type operating_system_type: str
        :param share_type: Filter the summary information based on the network
         share type. Values are 'SMB', 'NFS', 'ANY', or 'NONE'.
         Use **_ANY_** to return the total number of hosts that have any
         network share type set.
         Use **_NONE_** to return the total number of hosts that do not have
         network share type type set. Possible values include: 'SMB', 'NFS',
         'ANY', 'NONE'
        :type share_type: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ProtectedObjectsCount
         <rubriklib_int.models.ProtectedObjectsCount>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ProtectedObjectsCount
         <rubriklib_int.models.ProtectedObjectsCount>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/count'

        # Construct parameters
        query_parameters = {}
        if operating_system_type is not None:
            query_parameters['operating_system_type'] = self._serialize.query("operating_system_type", operating_system_type, 'str')
        if share_type is not None:
            query_parameters['share_type'] = self._serialize.query("share_type", share_type, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProtectedObjectsCount', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_host_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get host async request.

        Get details about a host related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_host_share(
            self, host_id=None, share_type=None, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for network shares.

        Retrieve summary information for network shares. Apply filters to
        refine the returned information.

        :param host_id: Filter the summary information based on the host id.
        :type host_id: str
        :param share_type: Filter the summary information based on the share
         type. Possible values include: 'NFS', 'SMB'
        :type share_type: str
        :param primary_cluster_id: Filters the summary information based on
         the Rubrik cluster specified by the value of primary_cluster_id. Use
         'local' for the Rubrik cluster that is hosting the current REST API
         session.
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostShareDetailListResponse
         <rubriklib_int.models.HostShareDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostShareDetailListResponse
         <rubriklib_int.models.HostShareDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share'

        # Construct parameters
        query_parameters = {}
        if host_id is not None:
            query_parameters['host_id'] = self._serialize.query("host_id", host_id, 'str')
        if share_type is not None:
            query_parameters['share_type'] = self._serialize.query("share_type", share_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostShareDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_share_to_host(
            self, share, custom_headers=None, raw=False, **operation_config):
        """Add a network share to a host.

        Add a network share object to a host.

        :param share: Network share creation definition.
        :type share: :class:`HostShareCreate
         <rubriklib_int.models.HostShareCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostShareDetail
         <rubriklib_int.models.HostShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostShareDetail
         <rubriklib_int.models.HostShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(share, 'HostShareCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('HostShareDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_host_share(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a network share.

        Retrieve detailed information for a network share.

        :param id: ID of the network share.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostShareDetail
         <rubriklib_int.models.HostShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostShareDetail
         <rubriklib_int.models.HostShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('HostShareDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def modify_host_share(
            self, id, share, custom_headers=None, raw=False, **operation_config):
        """Modify a network share.

        Modify a network share object.

        :param id: Modify network share with given ID.
        :type id: str
        :param share: Network share modification definition.
        :type share: :class:`HostSharePatch
         <rubriklib_int.models.HostSharePatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostShareDetail
         <rubriklib_int.models.HostShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostShareDetail
         <rubriklib_int.models.HostShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(share, 'HostSharePatch')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('HostShareDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_host_share(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a network share.

        Delete network by specifying the network share ID.

        :param id: Modify network share with given ID.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def search_host_share(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for a file within a network share.

        Search for a file within a network share. Search via full path prefix
        or filename prefix.

        :param id: ID of the network share to search
        :type id: str
        :param path: The path query. Either path prefix or filename prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_host_share_credential(
            self, host_id=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for host credential.

        Retrieve summary information for host credential. Apply filters to
        refine the returned information.

        :param host_id: Filter the summary information based on the host id.
        :type host_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostShareCredentialDetailListResponse
         <rubriklib_int.models.HostShareCredentialDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostShareCredentialDetailListResponse
         <rubriklib_int.models.HostShareCredentialDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share_credential'

        # Construct parameters
        query_parameters = {}
        if host_id is not None:
            query_parameters['host_id'] = self._serialize.query("host_id", host_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostShareCredentialDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_share_credential_to_host(
            self, share_credential, custom_headers=None, raw=False, **operation_config):
        """Add a share credential to a host.

        Add a share credential object to a host.

        :param share_credential: Host share credential creation definition.
        :type share_credential: :class:`HostShareCredentialDefinition
         <rubriklib_int.models.HostShareCredentialDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostShareCredentialDetail
         <rubriklib_int.models.HostShareCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostShareCredentialDetail
         <rubriklib_int.models.HostShareCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/share_credential'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(share_credential, 'HostShareCredentialDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('HostShareCredentialDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_host_async(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a registered host asynchronously.

        Delete host asynchronously by specifying the host ID.

        :param id: ID of the host to delete
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/{id}/async'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def set_host_flag(
            self, id, flag, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Modify physical host agent flags.

        REQUIRES SUPPORT TOKEN - Modify physical host agent flags to new
        values. Physical host agent flags are defined during compile-time. They
        can be passed in during agent startup or can be modified dynamically
        using this endpoint. A support token is required for this operation.

        :param id: ID of the registered host.
        :type id: str
        :param flag: Flag name and new value.
        :type flag: :class:`HostFlag <rubriklib_int.models.HostFlag>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/{id}/flag'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(flag, 'HostFlag')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_host_flag(
            self, id, flag, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Get the value for a physical host flag.

        REQUIRES SUPPORT TOKEN - Retrieve physical host agent flag value.
        Physical host agent flags are defined during compile-time. A support
        token is required for this operation.

        :param id: ID of the registered host.
        :type id: str
        :param flag: Flag name.
        :type flag: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostFlag <rubriklib_int.models.HostFlag>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostFlag <rubriklib_int.models.HostFlag>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/{id}/flag'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['flag'] = self._serialize.query("flag", flag, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostFlag', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def fetch_host_logs(
            self, id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Fetch host logs from agent into cluster.

        REQUIRES SUPPORT TOKEN - Fetch host logs from agent into cluster
        /internal/sd/scratch directory. A support token is required for this
        operation.

        :param id: ID of the registered host.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host/{id}/log'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def query_host_fileset(
            self, hostname=None, operating_system_type=None, operating_system=None, primary_cluster_id=None, effective_sla_domain_id=None, template_id=None, search_type=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for hosts.

        Retrieve summary information for all hosts that are registered with a
        Rubrik cluster. For each host, we also retrieve the summary information
        for the filesets applied to the host.

        :param hostname: Filter the summary information based on the hostname.
        :type hostname: str
        :param operating_system_type: Filter the summary information based on
         the operating system type. Values are 'Linux' or 'Windows'. Possible
         values include: 'Linux', 'Windows'
        :type operating_system_type: str
        :param operating_system: Filter the summary information based on the
         operating system of the host.
        :type operating_system: str
        :param primary_cluster_id: Filters the summary information based on
         the Rubrik cluster specified by the value of primary_cluster_id. Use
         'local' for the Rubrik cluster that is hosting the current REST API
         session.
        :type primary_cluster_id: str
        :param effective_sla_domain_id: Filter the summary information based
         on the ID of the effective SLA Domain inherited by filesets of the
         host. Use **_UNPROTECTED_** to only return information for hosts with
         filesets that do not have an effective SLA Domain. Use **_PROTECTED_**
         to only return information for hosts with filesets that do have an
         effective SLA Domain.
        :type effective_sla_domain_id: str
        :param template_id: Filter the summary information based on the ID of
         a fileset templates applied to the host. Use **_NO_FILESET_** to
         return information for hosts with no filesets. _NO_FILESET_ must be
         used with searchType 'exact'
        :type template_id: str
        :param search_type: Search type. Accepted values are 'infix' or
         'exact'. Default is 'exact'
        :type search_type: str
        :param sort_by: Comma-separated list of attributes by which to sort
         hostName | operatingSystem | operatingSystemType | status
        :type sort_by: str
        :param sort_order: Comma-separated list of sort orders (one for each
         sort_by) asc | desc,. Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostFilesetSummaryListResponse
         <rubriklib_int.models.HostFilesetSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostFilesetSummaryListResponse
         <rubriklib_int.models.HostFilesetSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host_fileset'

        # Construct parameters
        query_parameters = {}
        if hostname is not None:
            query_parameters['hostname'] = self._serialize.query("hostname", hostname, 'str')
        if operating_system_type is not None:
            query_parameters['operating_system_type'] = self._serialize.query("operating_system_type", operating_system_type, 'str')
        if operating_system is not None:
            query_parameters['operating_system'] = self._serialize.query("operating_system", operating_system, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if template_id is not None:
            query_parameters['template_id'] = self._serialize.query("template_id", template_id, 'str')
        if search_type is not None:
            query_parameters['search_type'] = self._serialize.query("search_type", search_type, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostFilesetSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_host_fileset_share(
            self, hostname=None, export_point=None, share_type=None, primary_cluster_id=None, effective_sla_domain_id=None, template_id=None, search_type=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for network shares.

        Retrieve summary information for the network shares that are registered
        with a Rubrik cluster, and summary information for the filesets that
        are assigned to each network share.

        :param hostname: Filter the summary information based on the hostname.
        :type hostname: str
        :param export_point: Filter the summary information based on the
         export point.
        :type export_point: str
        :param share_type: Filter the summary information based on the share
         type. Possible values include: 'NFS', 'SMB'
        :type share_type: str
        :param primary_cluster_id: Filters the summary information based on
         the Rubrik cluster specified by the value of primary_cluster_id. Use
         'local' for the Rubrik cluster that is hosting the current REST API
         session.
        :type primary_cluster_id: str
        :param effective_sla_domain_id: Filter the summary information based
         on the ID of the effective SLA Domain that is inherited by the
         filesets that are assigned to a network share. Use **_UNPROTECTED_**
         to only return information for network shares that have filesets
         without an effective SLA Domain. Use **_PROTECTED_** to only return
         information for network shares that have filesets with an effective
         SLA Domain.
        :type effective_sla_domain_id: str
        :param template_id: Filter the summary information based on the ID of
         a fileset templates applied to the network share. Use **_NO_FILESET_**
         to return information for network shares with no filesets.
         _NO_FILESET_ must be used with searchType 'exact'
        :type template_id: str
        :param search_type: Search type. Accepted values are 'infix' or
         'exact'. Default is 'exact'
        :type search_type: str
        :param sort_by: Comma-separated list of attributes that define the
         sort order of the search results. Use the following attributes to form
         the list: exportPoint | hostName | shareType | status
        :type sort_by: list of str
        :param sort_order: Comma-separated list of sort directions for each
         attribute type, use either 'asc' for ascending or 'desc' for
         descending. Match the order of the sort direction list values to the
         attribute list values to define the sort direction for each attribute
         type in the results.
         Comma-separated list of sort orders (one for each sort_by) asc |
         desc",
        :type sort_order: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostFilesetShareSummaryListResponse
         <rubriklib_int.models.HostFilesetShareSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostFilesetShareSummaryListResponse
         <rubriklib_int.models.HostFilesetShareSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host_fileset/share'

        # Construct parameters
        query_parameters = {}
        if hostname is not None:
            query_parameters['hostname'] = self._serialize.query("hostname", hostname, 'str')
        if export_point is not None:
            query_parameters['export_point'] = self._serialize.query("export_point", export_point, 'str')
        if share_type is not None:
            query_parameters['share_type'] = self._serialize.query("share_type", share_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if template_id is not None:
            query_parameters['template_id'] = self._serialize.query("template_id", template_id, 'str')
        if search_type is not None:
            query_parameters['search_type'] = self._serialize.query("search_type", search_type, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, '[str]', div=',')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostFilesetShareSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_host_fileset_share(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a network share.

        Retrieve detailed information for a network share, including detailed
        information for the filesets that are assigned to the network share.

        :param id: ID of the network share.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostFilesetShareDetail
         <rubriklib_int.models.HostFilesetShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostFilesetShareDetail
         <rubriklib_int.models.HostFilesetShareDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host_fileset/share/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostFilesetShareDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_host_fileset(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detail information for a host.

        Retrieve detail information for a registered host. For each host, we
        also retrieve the detail information for the filesets applied to the
        host.

        :param id: ID of the registered host.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostFilesetDetail
         <rubriklib_int.models.HostFilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostFilesetDetail
         <rubriklib_int.models.HostFilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/host_fileset/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostFilesetDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_hyperv_cluster(
            self, effective_sla_domain_id=None, primary_cluster_id=None, limit=None, offset=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary of all the Hyper-V hlusters.

        Get summary of all the Hyper-V hlusters.

        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: A comma-separated list of attributes to sort the
         results on. Possible values include: 'effectiveSlaDomainName', 'name'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervClusterSummaryListResponse
         <rubriklib_int.models.HypervClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervClusterSummaryListResponse
         <rubriklib_int.models.HypervClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/cluster'

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervClusterSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_cluster(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details of a Hyper-V cluster.

        Get details of a Hyper-V cluster.

        :param id: ID of the Hyper-V cluster
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervClusterDetail
         <rubriklib_int.models.HypervClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervClusterDetail
         <rubriklib_int.models.HypervClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervClusterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_hyperv_cluster(
            self, id, update_properties, custom_headers=None, raw=False, **operation_config):
        """Update Hyper-V cluster.

        Update cluster with specified properties.

        :param id: ID of Hyper-V cluster
        :type id: str
        :param update_properties: Properties to update
        :type update_properties: :class:`HypervClusterUpdate
         <rubriklib_int.models.HypervClusterUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervClusterDetail
         <rubriklib_int.models.HypervClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervClusterDetail
         <rubriklib_int.models.HypervClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'HypervClusterUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervClusterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_hierarchy_object(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary of a hierarchy object.

        Retrieve details for the specified hierarchy object.

        :param id: ID of the hierarchy object
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervHierarchyObjectSummary
         <rubriklib_int.models.HypervHierarchyObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervHierarchyObjectSummary
         <rubriklib_int.models.HypervHierarchyObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/hierarchy/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervHierarchyObjectSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_hierarchy_children(
            self, id, effective_sla_domain_id=None, object_type=None, primary_cluster_id=None, limit=None, offset=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of immediate descendant objects.

        Retrieve the list of immediate descendant objects for the specified
        parent.

        :param id: ID of the parent Hyper-V hierarchy object. To get top-level
         nodes, use **root** as the ID.
        :type id: str
        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param object_type: Filter by node object type
        :type object_type: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Attribute to sort the results on. Possible values
         include: 'effectiveSlaDomainName', 'name', 'descendentCount.cluster',
         'descendentCount.host', 'descendentCount.vm'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervHierarchyObjectSummaryListResponse
         <rubriklib_int.models.HypervHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervHierarchyObjectSummaryListResponse
         <rubriklib_int.models.HypervHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/hierarchy/{id}/children'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervHierarchyObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_hierarchy_descendants(
            self, id, effective_sla_domain_id=None, object_type=None, primary_cluster_id=None, limit=None, offset=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of descendant objects.

        Retrieve the list of descendant objects for the specified parent.

        :param id: ID of the parent Hyper-V hierarchy object
        :type id: str
        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param object_type: Filter by node object type. Possible values
         include: 'cluster', 'host', 'vm'
        :type object_type: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Attribute to sort the results on. Possible values
         include: 'effectiveSlaDomainName', 'name', 'descendentCount.cluster',
         'descendentCount.host', 'descendentCount.vm'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervHierarchyObjectSummaryListResponse
         <rubriklib_int.models.HypervHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervHierarchyObjectSummaryListResponse
         <rubriklib_int.models.HypervHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/hierarchy/{id}/descendants'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervHierarchyObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_hyperv_host(
            self, effective_sla_domain_id=None, primary_cluster_id=None, limit=None, offset=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary of all the Hyper-V hosts.

        Get summary of all the Hyper-V hosts.

        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Sort the result by the given attribute. Possible
         values include: 'effectiveSlaDomainName', 'name'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervHostSummaryListResponse
         <rubriklib_int.models.HypervHostSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervHostSummaryListResponse
         <rubriklib_int.models.HypervHostSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/host'

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervHostSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_host_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get Hyper-V host async request.

        Get details about a Hyper-V host related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/host/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_host(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details of a Hyper-V host.

        Get details of a Hyper-V host.

        :param id: ID of the Hyper-V host
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervHostDetail
         <rubriklib_int.models.HypervHostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervHostDetail
         <rubriklib_int.models.HypervHostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervHostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_hyperv_host(
            self, id, update_properties, custom_headers=None, raw=False, **operation_config):
        """Update Hyper-V host.

        Update host with specified properties.

        :param id: ID of Hyper-V host
        :type id: str
        :param update_properties: Properties to update
        :type update_properties: :class:`HypervHostUpdate
         <rubriklib_int.models.HypervHostUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervHostDetail
         <rubriklib_int.models.HypervHostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervHostDetail
         <rubriklib_int.models.HypervHostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'HypervHostUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervHostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def refresh_hyperv_host(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Refresh Hyper-V host metadata.

        Create a job to refresh the metadata for the specified Hyper-V host.

        :param id: ID of the Hyper-V host
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/host/{id}/refresh'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_hyperv_virtual_machine(
            self, effective_sla_domain_id=None, primary_cluster_id=None, limit=None, offset=None, name=None, sla_assignment=None, is_relic=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of VMs.

        Get summary of all the VMs.

        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param is_relic: Filter the summary information based on the relic
         status of the VM. Returns both relic and non relic if the parameter is
         not set.
        :type is_relic: bool
        :param sort_by: Sort the result by the given attribute. Possible
         values include: 'effectiveSlaDomainName', 'name'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineSummaryListResponse
         <rubriklib_int.models.HypervVirtualMachineSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineSummaryListResponse
         <rubriklib_int.models.HypervVirtualMachineSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm'

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_virtual_machine_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM async request details.

        Get details about a Hyper-V vm related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_hyperv_virtual_machine_snapshot_mount(
            self, vm_id=None, vm_name=None, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all live mounts.

        Retrieve the following information for all live mounts: ID, snapshot
        date, ID of source VM, name of source VM, ID of source host, status of
        the mount, mount event ID, and unmount event ID.

        :param vm_id: Filters live mounts by VM ID
        :type vm_id: str
        :param vm_name: Filters live mounts by VM name
        :type vm_name: str
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param limit: Limit the number of matches returned. Default is 25.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineMountSummaryListResponse
         <rubriklib_int.models.HypervVirtualMachineMountSummaryListResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineMountSummaryListResponse
         <rubriklib_int.models.HypervVirtualMachineMountSummaryListResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/mount'

        # Construct parameters
        query_parameters = {}
        if vm_id is not None:
            query_parameters['vm_id'] = self._serialize.query("vm_id", vm_id, 'str')
        if vm_name is not None:
            query_parameters['vm_name'] = self._serialize.query("vm_name", vm_name, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineMountSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_virtual_machine_snapshot_mount(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary information for a live mount.

        Retrieve the following summary information for a specified live mount:
        ID, snapshot date, ID of source VM, name of source VM, ID of source
        host, status of the mount, mount event ID, and unmount event ID.

        :param id: ID of the live mount
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineMountDetail
         <rubriklib_int.models.HypervVirtualMachineMountDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineMountDetail
         <rubriklib_int.models.HypervVirtualMachineMountDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineMountDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_hyperv_virtual_machine_snapshot_mount(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Power a Live Mount on and off.

        Power a specified Live Mount virtual machine on or off. Pass **_true_**
        to power the virtual machine on and pass **_false_** to power the
        virtual machine off.

        :param id: ID of a Live Mount.
        :type id: str
        :param config: Power state configuration.
        :type config: :class:`HypervUpdateMountConfig
         <rubriklib_int.models.HypervUpdateMountConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineMountDetail
         <rubriklib_int.models.HypervVirtualMachineMountDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineMountDetail
         <rubriklib_int.models.HypervVirtualMachineMountDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'HypervUpdateMountConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineMountDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_hyperv_virtual_machine_snapshot_mount(
            self, id, force=None, custom_headers=None, raw=False, **operation_config):
        """Requst to delete a live mount.

        Create a request to delete a live mount.

        :param id: ID of the mount to remove
        :type id: str
        :param force: Force unmount to deal with situations where host has
         been moved.
        :type force: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if force is not None:
            query_parameters['force'] = self._serialize.query("force", force, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_virtual_machine_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM snapshot details.

        Retrieve detailed information about a snapshot.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineSnapshotDetail
         <rubriklib_int.models.HypervVirtualMachineSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineSnapshotDetail
         <rubriklib_int.models.HypervVirtualMachineSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineSnapshotDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_hyperv_virtual_machine_snapshot(
            self, id, location, custom_headers=None, raw=False, **operation_config):
        """Delete VM snapshot.

        Delete a snapshot by expiring it. Snapshot is expired only if it is a
        manual snapshot or a snapshot of an unprotected vm.

        :param id: ID of snapshot
        :type id: str
        :param location: Snapshot location to delete. Use **_local_** to
         delete all local snapshots and **_all_** to delete the snapshot in all
         locations. Possible values include: 'all', 'local'
        :type location: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['location'] = self._serialize.query("location", location, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def browse_hyperv_virtual_machine_snapshot(
            self, id, path, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Lists all files in VM snapshot.

        Lists all files and directories in a given path.

        :param id: ID of snapshot
        :type id: str
        :param path: The absolute path to start the directory listing from.
        :type path: str
        :param offset: Starting position in the list of path entries contained
         in the query results, sorted by lexicographical order. The response
         includes the specified numbered entry and all higher numbered entries.
        :type offset: int
        :param limit: Maximum number of entries in the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/browse'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BrowseResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def download_hyperv_virtual_machine_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Creates a download from archival request.

        Download a snapshot from archival.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/download'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def download_hyperv_virtual_machine_snapshot_file(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Download file from VM snapshot.

        Create a download file request.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for a download request
        :type config: :class:`HypervDownloadFileJobConfig
         <rubriklib_int.models.HypervDownloadFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/download_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'HypervDownloadFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def export_hyperv_virtual_machine_snapshot(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Export VM snapshot.

        Export snapshot of a vm.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for the export request
        :type config: :class:`HypervExportSnapshotJobConfig
         <rubriklib_int.models.HypervExportSnapshotJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/export'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'HypervExportSnapshotJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def recover_hyperv_virtual_machine_snapshot(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Creates an instant recover request that restores a target VM from the
        given Rubrik-hosted-snapshot.

        The VM will be started with networking enabled. If the VM does not
        exist anymore, a new VM will be created.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for the instant recover request
        :type config: :class:`HypervInstantRecoveryJobConfig
         <rubriklib_int.models.HypervInstantRecoveryJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/instant_recover'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'HypervInstantRecoveryJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_hyperv_virtual_machine_snapshot_mount(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Create a live mount request.

        Create a live mount request with given configuration.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for the mount request
        :type config: :class:`HypervMountSnapshotJobConfig
         <rubriklib_int.models.HypervMountSnapshotJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/mount'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'HypervMountSnapshotJobConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def restore_hyperv_virtual_machine_snapshot_file(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Restore file from VM snapshot.

        Restore files to the original VM.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for a restore job
        :type config: :class:`HypervRestoreFileConfig
         <rubriklib_int.models.HypervRestoreFileConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/snapshot/{id}/restore_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'HypervRestoreFileConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hyperv_virtual_machine(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM details.

        Detailed view of a VM.

        :param id: ID of the Virtual Machine.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineDetail
         <rubriklib_int.models.HypervVirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineDetail
         <rubriklib_int.models.HypervVirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_hyperv_virtual_machine(
            self, id, vm_update_properties, custom_headers=None, raw=False, **operation_config):
        """Update VM.

        Update VM with specified properties.

        :param id: ID of Virtual Machine
        :type id: str
        :param vm_update_properties: Properties to update
        :type vm_update_properties: :class:`HypervVirtualMachineUpdate
         <rubriklib_int.models.HypervVirtualMachineUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineDetail
         <rubriklib_int.models.HypervVirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineDetail
         <rubriklib_int.models.HypervVirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(vm_update_properties, 'HypervVirtualMachineUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_hyperv_virtual_machine_missed_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about missed snapshots for a VM.

        Retrieve the time of the day when the snapshots were missed specific to
        a vm.

        :param id: ID of the vm
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MissedSnapshotListResponse
         <rubriklib_int.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MissedSnapshotListResponse
         <rubriklib_int.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}/missed_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MissedSnapshotListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def hyperv_vm_register_agent(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Register the agent installed in VM.

        Register the agent that installed in VM.

        :param id: ID of the Virtual Machine
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}/register_agent'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def search_hyperv_virtual_machine(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for file in VM.

        Search for a file within the Virtual Machine. Search via full path
        prefix or filename prefix.

        :param id: ID of the vm
        :type id: str
        :param path: The path query. Either path prefix or filename prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_hyperv_virtual_machine_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get list of snapshots of VM.

        Retrieve the following information for all snapshots for a VM: ID,
        snapshot date, expiration date, type of source object, Name of VM, Name
        of fileset, type of snapshot, state of the cloud, level of consistency,
        name of snapshot VM, Index of state, total number of file, IDs of all
        replication location, IDs of all archival location.

        :param id: ID of the vm
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HypervVirtualMachineSnapshotSummaryListResponse
         <rubriklib_int.models.HypervVirtualMachineSnapshotSummaryListResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HypervVirtualMachineSnapshotSummaryListResponse
         <rubriklib_int.models.HypervVirtualMachineSnapshotSummaryListResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HypervVirtualMachineSnapshotSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_hyperv_virtual_machine_snapshot(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Create on-demand VM snapshot.

        Create an on-demand snapshot for the given VM ID.

        :param id: ID of the VM
        :type id: str
        :param config: Configuration for the on-demand backup.
        :type config: :class:`BaseOnDemandSnapshotConfig
         <rubriklib_int.models.BaseOnDemandSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'BaseOnDemandSnapshotConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_hyperv_virtual_machine_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete all snapshots of VM.

        Delete all snapshots of a virtual machine.

        :param id: Virtual machine ID
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/hyperv/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def schedule_delete_replication_source_job(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - deletes a replication source cluster on the
        target cluster.

        REQUIRES SUPPORT TOKEN - Deletes a replication source cluster on the
        target cluster. A support token is required for this operation.

        :param config: Configuration for the delete replication source job
        :type config: :class:`DeleteReplicationSourceJobConfig
         <rubriklib_int.models.DeleteReplicationSourceJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/deleteReplicationSource'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'DeleteReplicationSourceJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_instances(
            self, status=None, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Query for job instances.

        REQUIRES SUPPORT TOKEN - This is just for easier diagnosis to figure
        out what jobs there are in the system. A support token is required for
        this operation.

        :param status: Status of job instance
        :type status: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/instance'

        # Construct parameters
        query_parameters = {}
        if status is not None:
            query_parameters['status'] = self._serialize.query("status", status, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[InternalJobInstanceDetail]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_job_instances(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - list of job instances.

        REQUIRES SUPPORT TOKEN - Get instances by job id and status. A support
        token is required for this operation.

        :param config: job id and status(optional)
        :type config: :class:`InstancesConfig
         <rubriklib_int.models.InstancesConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/instances'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'InstancesConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[InternalJobInstanceDetail]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def schedule_gc_job_start_time_now(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN -  sets the start time of the next queued GC job
        to be the current date and time.

        REQUIRES SUPPORT TOKEN - Sets the start time of the next queued GC job
        to be the current date and time. A support token is required for this
        operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/schedule_gc_job_start_time_now'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)
        if response.status_code == 404:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_vm_backup_job(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Create a backup job instance.

        TODO.

        :param config: Configuration for the backup job
        :type config: :class:`BackupJobConfig
         <rubriklib_int.models.BackupJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`Status <rubriklib_int.models.Status>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`Status <rubriklib_int.models.Status>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/backup'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'BackupJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Status', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_clean_up_references(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Creates a job to clean up references
        (semaphores, throttles, replication targets).

        REQUIRES SUPPORT TOKEN - Creates a job to clean up references
        (semaphores, throttles, replication targets). A support token is
        required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/clean_up_references'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [201, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('str', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_expire(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Create an expire snapshot job instance.

        TODO.

        :param config: Configuration for the expire snapshot job
        :type config: :class:`ExpireSnapshotJobConfig
         <rubriklib_int.models.ExpireSnapshotJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/expire'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'ExpireSnapshotJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 404, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)
        if response.status_code == 404:
            deserialized = self._deserialize('str', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_garbage_collection(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Create a garbage collection job instance.

        TODO.

        :param config: Configuration for the garbage collection job
        :type config: :class:`GarbageCollectionJobConfig
         <rubriklib_int.models.GarbageCollectionJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/garbageCollection'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'GarbageCollectionJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_prune_job_instances(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Creates a job to prune job instances.

        REQUIRES SUPPORT TOKEN - Creates a job to prune job instances. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/prune_job_instances'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [201, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('str', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_snapshot_integrity(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Verify integrity of a VM''s snapshots.

        REQUIRES SUPPORT TOKEN - Calculate the SHA-1 hash of each snapshot. The
        first time we verify a snapshot, we simply record its hash in
        Cassandra. During subsequent runs, we check the hash against the
        recorded hash. A support token is required for this operation.

        :param config: Configuration for the snapshot integrity job
        :type config: :class:`SnapshotIntegrityJobConfig
         <rubriklib_int.models.SnapshotIntegrityJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/snapshot_integrity'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'SnapshotIntegrityJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def vm_job_maintainer(
            self, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Creates a job that maintains other VM jobs.

        REQUIRES SUPPORT TOKEN - Creates a job that maintains other VM jobs. A
        support token is required for this operation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/type/vmJobMaintainer'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_job_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Get details about a job instance.

        REQUIRES SUPPORT TOKEN - Retrieve the following information about job
        instance- ID of job instance, job status, error details, start time of
        job, end time of job, job type, ID of the node and job progress. A
        support token is required for this operation.

        :param id: ID of Job instance
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('InternalJobInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_job(
            self, id, job_update_properties, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - End point to update general properties of a
        job.

        REQUIRES SUPPORT TOKEN - This is to allow one to update general
        properties of a job. A support token is required for this operation.

        :param id: ID of the job
        :type id: str
        :param job_update_properties: Properties to update
        :type job_update_properties: :class:`JobUpdate
         <rubriklib_int.models.JobUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobDetail <rubriklib_int.models.JobDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobDetail <rubriklib_int.models.JobDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/job/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(job_update_properties, 'JobUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('JobDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def log(
            self, log_message, custom_headers=None, raw=False, **operation_config):
        """INTERNAL ONLY: Log a message.

        Used by UI to generate logs.

        :param log_message: Details of message to log
        :type log_message: :class:`LogMessage
         <rubriklib_int.models.LogMessage>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/log'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(log_message, 'LogMessage')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_bulk_summary(
            self, objects, sort_attr=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Gets the summaries of a set of managed objects.

        Gets the summaries of a set of managed objects.

        :param objects: List of managed IDs whose summaries to get
        :type objects: :class:`ManagedIdList
         <rubriklib_int.models.ManagedIdList>`
        :param sort_attr: Comma-separated list of attributes by which to sort:
         name|objectType|hostname
        :type sort_attr: list of str
        :param sort_order: Comma-separated list of sort orders (one for each
         sort_attr): asc|desc
        :type sort_order: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedObjectSummaryListResponse
         <rubriklib_int.models.ManagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedObjectSummaryListResponse
         <rubriklib_int.models.ManagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_object/bulk/summary'

        # Construct parameters
        query_parameters = {}
        if sort_attr is not None:
            query_parameters['sort_attr'] = self._serialize.query("sort_attr", sort_attr, '[str]', div=',')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(objects, 'ManagedIdList')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_object_children(
            self, managed_id, limit=None, object_type=None, operating_system_type=None, offset=None, primary_cluster_id=None, search_attr=None, search_value=None, search_type=None, join_operator=None, sort_attr=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Gets the summaries of a managed object's children.

        Gets the summaries of a managed object's immediate children.

        :param managed_id: ManagedID of object whose summary to get
        :type managed_id: str
        :param limit: Maximum number of results to return
        :type limit: int
        :param object_type: Comma-separated list of objectType values by which
         to search (all if not specified)
        :type object_type: list of str
        :param operating_system_type: Comma-separated list of
         operatingSystemType values by which to search (all if not specified):
         Linux|Windows
        :type operating_system_type: list of str
        :param offset: Starting offset of the results to return
        :type offset: int
        :param primary_cluster_id: Filter by primary cluster ID, or local
        :type primary_cluster_id: str
        :param search_attr: Comma-separated list of attributes by which to
         search: name|hostname
        :type search_attr: list of str
        :param search_value: Comma-separated list of values by which to search
         (one for each search_attr)
        :type search_value: list of str
        :param search_type: Comma-separated list of search types (one for each
         search_attr): prefix|infix|exact
        :type search_type: list of str
        :param join_operator: Whether results must match any or all of the
         search attributes: all|any (default is "all")
        :type join_operator: str
        :param sort_attr: Comma-separated list of attributes by which to sort:
         name|objectType|hostname
        :type sort_attr: list of str
        :param sort_order: Comma-separated list of sort orders (one for each
         sort_attr): asc|desc
        :type sort_order: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedObjectSummaryListResponse
         <rubriklib_int.models.ManagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedObjectSummaryListResponse
         <rubriklib_int.models.ManagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_object/{managed_id}/children'
        path_format_arguments = {
            'managed_id': self._serialize.url("managed_id", managed_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, '[str]', div=',')
        if operating_system_type is not None:
            query_parameters['operating_system_type'] = self._serialize.query("operating_system_type", operating_system_type, '[str]', div=',')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if search_attr is not None:
            query_parameters['search_attr'] = self._serialize.query("search_attr", search_attr, '[str]', div=',')
        if search_value is not None:
            query_parameters['search_value'] = self._serialize.query("search_value", search_value, '[str]', div=',')
        if search_type is not None:
            query_parameters['search_type'] = self._serialize.query("search_type", search_type, '[str]', div=',')
        if join_operator is not None:
            query_parameters['join_operator'] = self._serialize.query("join_operator", join_operator, 'str')
        if sort_attr is not None:
            query_parameters['sort_attr'] = self._serialize.query("sort_attr", sort_attr, '[str]', div=',')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_object_descendants(
            self, managed_id, limit=None, object_type=None, operating_system_type=None, offset=None, primary_cluster_id=None, search_attr=None, search_value=None, search_type=None, join_operator=None, sort_attr=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Gets the summaries of a managed object's descendants.

        Gets the summaries of all the descendants of a managed object.

        :param managed_id: ManagedID of object whose descendants to get
        :type managed_id: str
        :param limit: Maximum number of results to return
        :type limit: int
        :param object_type: Comma-separated list of objectType values by which
         to search (all if not specified):
         ComputeCluster|DataCenter|Fileset|Folder|Global|Host|MssqlDatabase|MssqlInstance|VirtualMachine|VmwareHost|vCenter
        :type object_type: list of str
        :param operating_system_type: Comma-separated list of
         operatingSystemType values by which to search (all if not specified):
         Linux|Windows
        :type operating_system_type: list of str
        :param offset: Starting offset of the results to return
        :type offset: int
        :param primary_cluster_id: Filter by primary cluster ID, or local
        :type primary_cluster_id: str
        :param search_attr: Comma-separated list of attributes by which to
         search: name|hostname
        :type search_attr: list of str
        :param search_value: Comma-separated list of values by which to search
         (one for each search_attr)
        :type search_value: list of str
        :param search_type: Comma-separated list of search types (one for each
         search_attr): prefix|infix|exact
        :type search_type: list of str
        :param join_operator: Whether results must match any or all of the
         search attributes: all|any (default is "all")
        :type join_operator: str
        :param sort_attr: Comma-separated list of attributes by which to sort:
         name|objectType|hostname
        :type sort_attr: list of str
        :param sort_order: Comma-separated list of sort orders (one for each
         sort_attr): asc|desc
        :type sort_order: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedObjectSummaryListResponse
         <rubriklib_int.models.ManagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedObjectSummaryListResponse
         <rubriklib_int.models.ManagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_object/{managed_id}/descendants'
        path_format_arguments = {
            'managed_id': self._serialize.url("managed_id", managed_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, '[str]', div=',')
        if operating_system_type is not None:
            query_parameters['operating_system_type'] = self._serialize.query("operating_system_type", operating_system_type, '[str]', div=',')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if search_attr is not None:
            query_parameters['search_attr'] = self._serialize.query("search_attr", search_attr, '[str]', div=',')
        if search_value is not None:
            query_parameters['search_value'] = self._serialize.query("search_value", search_value, '[str]', div=',')
        if search_type is not None:
            query_parameters['search_type'] = self._serialize.query("search_type", search_type, '[str]', div=',')
        if join_operator is not None:
            query_parameters['join_operator'] = self._serialize.query("join_operator", join_operator, 'str')
        if sort_attr is not None:
            query_parameters['sort_attr'] = self._serialize.query("sort_attr", sort_attr, '[str]', div=',')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_object_summary(
            self, managed_id, custom_headers=None, raw=False, **operation_config):
        """Gets the summary of a managed object.

        Gets the summary of a managed object.

        :param managed_id: ManagedID of object whose summary to get
        :type managed_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedObjectSummary
         <rubriklib_int.models.ManagedObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedObjectSummary
         <rubriklib_int.models.ManagedObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_object/{managed_id}/summary'
        path_format_arguments = {
            'managed_id': self._serialize.url("managed_id", managed_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedObjectSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_managed_volume(
            self, is_relic=None, primary_cluster_id=None, name=None, effective_sla_domain_id=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for managed volumes.

        Retrieve summary information for all managed volumes that are created
        within a Rubrik cluster.

        :param is_relic: Filter by isRelic field. Return both relic and
         non-relic managed volumes if this query is not set.
        :type is_relic: bool
        :param primary_cluster_id: Filters the summary information based on
         the Rubrik cluster specified by the value of primary_cluster_id. Use
         'local' for the Rubrik cluster that is hosting the current REST API
         session.
        :type primary_cluster_id: str
        :param name: Retrieve managed volumes with a name matching the
         provided name. The search type is infix.
        :type name: str
        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param sort_by: Specifies the managed volume attribute to use in
         sorting the managed volume summary information. Performs an ASCII sort
         of the summary information using the specified attribute, in the order
         specified.
         Valid attributes are 'name' and 'effectiveSlaDomainId'. Possible
         values include: 'name'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSummaryListResponse
         <rubriklib_int.models.ManagedVolumeSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSummaryListResponse
         <rubriklib_int.models.ManagedVolumeSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume'

        # Construct parameters
        query_parameters = {}
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_managed_volume(
            self, managed_volume_config, custom_headers=None, raw=False, **operation_config):
        """Create a managed volume.

        Create a managed volume.

        :param managed_volume_config: Managed volume configuration.
        :type managed_volume_config: :class:`ManagedVolumeConfig
         <rubriklib_int.models.ManagedVolumeConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSummary
         <rubriklib_int.models.ManagedVolumeSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSummary
         <rubriklib_int.models.ManagedVolumeSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(managed_volume_config, 'ManagedVolumeConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('ManagedVolumeSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_managed_volume_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get managed volume async request status.

        Get status of a managed volume async request.

        :param id: ID of the request.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_managed_volume_snapshot_export(
            self, source_managed_volume_id=None, source_managed_volume_name=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all managed volume snapshot exports.

        Returns a list of summary information for all exports of all managed
        volume snapshots, sorted and filtered.

        :param source_managed_volume_id: Filter snapshot exports to those that
         belong to the managed volume with given id.
        :type source_managed_volume_id: str
        :param source_managed_volume_name: Filter snapshot exports to those
         that belong to the managed volume with given name using infix search.
        :type source_managed_volume_name: str
        :param sort_by: Specifies the managed volume export attribute to use
         in sorting the managed volume summary information. Performs an ASCII
         sort of the summary information using the specified attribute, in the
         order specified.
         Valid attributes are 'status', 'snapshotDate',
         'sourceManagedVolumeName', 'exportedDate'. Possible values include:
         'status', 'snapshotDate', 'sourceManagedVolumeName', 'exportedDate'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSnapshotExportSummaryListResponse
         <rubriklib_int.models.ManagedVolumeSnapshotExportSummaryListResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSnapshotExportSummaryListResponse
         <rubriklib_int.models.ManagedVolumeSnapshotExportSummaryListResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/export'

        # Construct parameters
        query_parameters = {}
        if source_managed_volume_id is not None:
            query_parameters['source_managed_volume_id'] = self._serialize.query("source_managed_volume_id", source_managed_volume_id, 'str')
        if source_managed_volume_name is not None:
            query_parameters['source_managed_volume_name'] = self._serialize.query("source_managed_volume_name", source_managed_volume_name, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSnapshotExportSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_managed_volume_snapshot_export(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a managed volume snapshot export.

        Delete a managed volume snapshot export.

        :param id: ID of snapshot export.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/export/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def delete_managed_volume_snapshot(
            self, id, location=None, custom_headers=None, raw=False, **operation_config):
        """Delete a managed volume snapshot.

        Delete a managed volume snapshot.

        :param id: ID of snapshot
        :type id: str
        :param location: Snapshot location to delete. Use **_local_** to
         delete all local snapshots and **_all_** to delete the snapshot in all
         locations. Defaults to **_all_** if not set. Possible values include:
         'all', 'local'
        :type location: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if location is not None:
            query_parameters['location'] = self._serialize.query("location", location, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_managed_volume_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get managed volume snapshot details.

        Retrieve detailed information about a snapshot.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSnapshotDetail
         <rubriklib_int.models.ManagedVolumeSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSnapshotDetail
         <rubriklib_int.models.ManagedVolumeSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSnapshotDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def browse_managed_volume_snapshot(
            self, id, path, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Lists all files in Managed volume snapshot.

        Lists all files and directories in a given path.

        :param id: ID of snapshot
        :type id: str
        :param path: The absolute path of the starting point for the directory
         listing.
        :type path: str
        :param offset: Starting position in the list of path entries contained
         in the query results, sorted by lexicographical order. The response
         includes the specified numbered entry and all higher numbered entries.
        :type offset: int
        :param limit: Maximum number of entries in the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/{id}/browse'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BrowseResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_download_managed_volume_snapshot_from_cloud(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Create a download managed volume snapshot from archival request.

        Create a download managed volume snapshot from archival request.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/{id}/download'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_managed_volume_download_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Download file from Managed volume snapshot.

        Create a download file request.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for a download request
        :type config: :class:`ManagedVolumeDownloadFileJobConfig
         <rubriklib_int.models.ManagedVolumeDownloadFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/{id}/download_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'ManagedVolumeDownloadFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def export_snapshot(
            self, id, params, custom_headers=None, raw=False, **operation_config):
        """Create a request to export a snapshot.

        Export a managed volume snapshot as a share.

        :param id: ID of snapshot.
        :type id: str
        :param params: Export parameters.
        :type params: :class:`ManagedVolumeExportConfig
         <rubriklib_int.models.ManagedVolumeExportConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/snapshot/{id}/export'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(params, 'ManagedVolumeExportConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_managed_volume(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details of a managed volume.

        Details of a managed volume.

        :param id: ID of the managed volume.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSummary
         <rubriklib_int.models.ManagedVolumeSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSummary
         <rubriklib_int.models.ManagedVolumeSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_managed_volume(
            self, id, update, custom_headers=None, raw=False, **operation_config):
        """Update managed volume.

        Update managed volume with specified properties.

        :param id: ID of managed volume.
        :type id: str
        :param update: Properties to update.
        :type update: :class:`ManagedVolumeUpdate
         <rubriklib_int.models.ManagedVolumeUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSummary
         <rubriklib_int.models.ManagedVolumeSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSummary
         <rubriklib_int.models.ManagedVolumeSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'ManagedVolumeUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_managed_volume(
            self, id, preserve_snapshots=None, custom_headers=None, raw=False, **operation_config):
        """Delete a managed volume.

        Delete a managed volume.

        :param id: ID of managed volume.
        :type id: str
        :param preserve_snapshots: Flag to indicate whether to convert
         snapshots of this managed volume to relics or to delete them.  Default
         is true.
        :type preserve_snapshots: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if preserve_snapshots is not None:
            query_parameters['preserve_snapshots'] = self._serialize.query("preserve_snapshots", preserve_snapshots, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def open_writes(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Begin managed volume snapshot.

        Opens the managed volume for writes. All writes to the managed volume
        until next end-snapshot call will be part of this snapshot.

        :param id: ID of managed volume.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}/begin_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def close_writes(
            self, id, params=None, custom_headers=None, raw=False, **operation_config):
        """End managed volume snapshot.

        Close a managed volume for writes. A snapshot will be created
        containing all writes since the last begin-snapshot call.

        :param id: ID of managed volume.
        :type id: str
        :param params: Snapshot parameters.
        :type params: :class:`ManagedVolumeSnapshotConfig
         <rubriklib_int.models.ManagedVolumeSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSnapshotSummary
         <rubriklib_int.models.ManagedVolumeSnapshotSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSnapshotSummary
         <rubriklib_int.models.ManagedVolumeSnapshotSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}/end_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if params is not None:
            body_content = self._serialize.body(params, 'ManagedVolumeSnapshotConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSnapshotSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reset_managed_volume(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Reset a managed volume.

        Reset a managed volume to the last successful snapshot.

        :param id: ID of managed volume
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}/reset'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def search_managed_volume(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for files in a managed volume.

        Search a managed volume for files.

        :param id: ID of the managed volume
        :type id: str
        :param path: The path query. Either path prefix or filename prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_managed_volume_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary information for snapshots of a managed volume.

        Returns a list of summary information for snapshots of a managed
        volume.

        :param id: ID of the managed volume.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ManagedVolumeSnapshotSummaryListResponse
         <rubriklib_int.models.ManagedVolumeSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ManagedVolumeSnapshotSummaryListResponse
         <rubriklib_int.models.ManagedVolumeSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/managed_volume/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ManagedVolumeSnapshotSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_mssql_availability_group(
            self, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for Microsoft SQL availability groups.

        Returns a list of summary information for Microsoft SQL availability
        groups.

        :param primary_cluster_id: Filter by primary cluster.
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlAvailabilityGroupSummaryListResponse
         <rubriklib_int.models.MssqlAvailabilityGroupSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlAvailabilityGroupSummaryListResponse
         <rubriklib_int.models.MssqlAvailabilityGroupSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/availability_group'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlAvailabilityGroupSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_availability_group(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a Microsoft SQL availability group.

        Returns a detailed view of a Microsoft SQL availability group.

        :param id: ID of the Microsoft SQL availability group to fetch.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlAvailabilityGroupDetail
         <rubriklib_int.models.MssqlAvailabilityGroupDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlAvailabilityGroupDetail
         <rubriklib_int.models.MssqlAvailabilityGroupDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/availability_group/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlAvailabilityGroupDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_mssql_availability_group(
            self, id, update_properties, custom_headers=None, raw=False, **operation_config):
        """Update a Microsoft SQL availability group.

        Update a Microsoft SQL availability group with the specified
        properties.

        :param id: ID of the Microsoft SQL availability group to update.
        :type id: str
        :param update_properties: Properties to update.
        :type update_properties: :class:`MssqlAvailabilityGroupUpdate
         <rubriklib_int.models.MssqlAvailabilityGroupUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlAvailabilityGroupDetail
         <rubriklib_int.models.MssqlAvailabilityGroupDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlAvailabilityGroupDetail
         <rubriklib_int.models.MssqlAvailabilityGroupDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/availability_group/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'MssqlAvailabilityGroupUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlAvailabilityGroupDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_update_mssql_db(
            self, dbs_update_properties, custom_headers=None, raw=False, **operation_config):
        """Update multiple Microsoft SQL databases.

        Update multiple Microsoft SQL databases with the specified properties.

        :param dbs_update_properties: Properties to update for each database.
        :type dbs_update_properties: list of :class:`MssqlDbUpdateId
         <rubriklib_int.models.MssqlDbUpdateId>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`MssqlDbDetail
         <rubriklib_int.models.MssqlDbDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`MssqlDbDetail
         <rubriklib_int.models.MssqlDbDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(dbs_update_properties, '[MssqlDbUpdateId]')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MssqlDbDetail]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def count_mssql_db(
            self, root_id=None, custom_headers=None, raw=False, **operation_config):
        """Get a count of Microsoft SQL databases.

        Returns a count of Microsoft SQL databases.

        :param root_id: Include only instances that belong to this root.
        :type root_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ProtectedObjectsCount
         <rubriklib_int.models.ProtectedObjectsCount>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ProtectedObjectsCount
         <rubriklib_int.models.ProtectedObjectsCount>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/count'

        # Construct parameters
        query_parameters = {}
        if root_id is not None:
            query_parameters['root_id'] = self._serialize.query("root_id", root_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProtectedObjectsCount', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_default_db_properties(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the current default properties for Microsoft SQL databases.

        The default properties are Log Backup Frequency (minutes) and Log
        Backup Retention (Days). New databases added to the Rubrik system will
        be given these values as their defaults.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbDefaults
         <rubriklib_int.models.MssqlDbDefaults>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbDefaults
         <rubriklib_int.models.MssqlDbDefaults>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/defaults'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbDefaults', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_default_db_properties(
            self, default_properties, custom_headers=None, raw=False, **operation_config):
        """Update the default properties for Microsoft SQL databases.

        The default properties are Log Backup Frequency (minutes) and Log
        Backup Retention (Days). New databases added to the Rubrik system will
        be given these values as their defaults.

        :param default_properties: Updated default properties.
        :type default_properties: :class:`MssqlDbDefaults
         <rubriklib_int.models.MssqlDbDefaults>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbDefaults
         <rubriklib_int.models.MssqlDbDefaults>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbDefaults
         <rubriklib_int.models.MssqlDbDefaults>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/defaults'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(default_properties, 'MssqlDbDefaults')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbDefaults', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_delete_mssql_db_recoverable_ranges_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get the deletion status of downloaded recoverable ranges.

        Get the details of the progress made in deleting recoverable ranges.
        The recoverable ranges to delete are those specified by the DELETE
        request to /mssql/db/{id}/recoverable_range/download which yielded the
        response with the job id.

        :param id: Job ID of the deletion for which to check progress.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`InternalJobInstanceDetail
         <rubriklib_int.models.InternalJobInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/recoverable_range/download/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('InternalJobInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def mssql_db_assign_to_sla(
            self, id, assignment_info, custom_headers=None, raw=False, **operation_config):
        """Assign mssql databases to an SLA Domain.

        Assign mssql databases to the specified SLA Domain. Note that this
        assignment can fail, as at most one database in each availability group
        can be protected. When the force parameter is set to true,
        currently-protected databases may be unprotected in order allow
        protecting the specified databases. Assignment is not guaranteed to
        succeed even when force is set to true. For example, a request to
        protect two databases in the same availability group will always fail.

        :param id: ID of the SLA Domain.
        :type id: str
        :param assignment_info: SLA assignment information
        :type assignment_info: :class:`MssqlDbSlaAssignment
         <rubriklib_int.models.MssqlDbSlaAssignment>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/sla/{id}/assign'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(assignment_info, 'MssqlDbSlaAssignment')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbSlaAssignStatus', response)
        if response.status_code == 409:
            deserialized = self._deserialize('MssqlDbAssignToSlaConflictResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def mssql_db_availability_group_conflicts(
            self, id, assignment_info, custom_headers=None, raw=False, **operation_config):
        """Get availability group conflicts that would occur under the specified
        SLA Domain assignment.

        Checks for conflicts under an assignment of Microsoft SQL databases to
        the specified SLA Domain.

        :param id: ID of the SLA Domain.
        :type id: str
        :param assignment_info: SLA assignment information.
        :type assignment_info: :class:`MssqlDbSlaConflictCheck
         <rubriklib_int.models.MssqlDbSlaConflictCheck>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbSlaConflictInfo
         <rubriklib_int.models.MssqlDbSlaConflictInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbSlaConflictInfo
         <rubriklib_int.models.MssqlDbSlaConflictInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/sla/{id}/availability_group_conflicts'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(assignment_info, 'MssqlDbSlaConflictCheck')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbSlaConflictInfo', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_compatible_mssql_instances(
            self, id, recovery_time, recovery_type, custom_headers=None, raw=False, **operation_config):
        """Get compatible instances for the recovery of a Microsoft SQL database.

        Returns all compatible instances for export for a given recovery time.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param recovery_time: Time to recover to. The date-time string should
         be in ISO8601 format, such as "2016-01-01T01:23:45.678Z".
        :type recovery_time: datetime
        :param recovery_type: Recovery type. Possible values include: 'Mount',
         'Export', 'Restore'
        :type recovery_type: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlInstanceSummaryListResponse
         <rubriklib_int.models.MssqlInstanceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlInstanceSummaryListResponse
         <rubriklib_int.models.MssqlInstanceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/{id}/compatible_instance'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['recovery_time'] = self._serialize.query("recovery_time", recovery_time, 'iso-8601')
        query_parameters['recovery_type'] = self._serialize.query("recovery_type", recovery_type, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlInstanceSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_downloaded_mssql_db_recoverable_ranges(
            self, id, after_time=None, before_time=None, custom_headers=None, raw=False, **operation_config):
        """Delete downloaded recoverable ranges of a Microsoft SQL database.

        Deletes all local snapshots and logs that have previously been
        downloaded. A begin and/or end time can be provided to delete only the
        downloaded snapshots and logs that fall within the window. The time is
        relative to when the snapshot or log backup was originally taken, not
        downloaded. Parts of the window may not be deleted if certain log files
        must be kept to preserve times outside the window. Data is deleted in
        the background. To check the status of the deletion, poll
        /mssql/db/recoverable_range/downloaded/{id}.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param after_time: Delete only the downloaded snapshots and logs taken
         after this time. The date-time string should be in ISO8601 format,
         such as "2016-01-01T01:23:45.678".
        :type after_time: datetime
        :param before_time: Delete only the downloaded snapshots and logs
         taken before this time. The date-time string should be in ISO8601
         format, such as "2016-01-01T01:23:45.678".
        :type before_time: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`JobScheduledResponse
         <rubriklib_int.models.JobScheduledResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/{id}/recoverable_range/download'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if after_time is not None:
            query_parameters['after_time'] = self._serialize.query("after_time", after_time, 'iso-8601')
        if before_time is not None:
            query_parameters['before_time'] = self._serialize.query("before_time", before_time, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('JobScheduledResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def mssql_restore_estimate(
            self, id, time=None, lsn=None, recovery_fork_guid=None, custom_headers=None, raw=False, **operation_config):
        """Get a size estimate for a restore or export.

        Provides an estimate of resources needed for the specified restore or
        export operation.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param time: Time to recover to, in ISO8601 date-time format, such as
         "2016-01-01T01:23:45.678". Either this or the LSN must be specified.
        :type time: datetime
        :param lsn: LSN to recover to. Either this or time must be specified.
        :type lsn: str
        :param recovery_fork_guid: Recovery fork GUID of LSN to recover to.
         Has meaning only when lsn is specified.
        :type recovery_fork_guid: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlRestoreEstimateResult
         <rubriklib_int.models.MssqlRestoreEstimateResult>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlRestoreEstimateResult
         <rubriklib_int.models.MssqlRestoreEstimateResult>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/{id}/restore_estimate'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if time is not None:
            query_parameters['time'] = self._serialize.query("time", time, 'iso-8601')
        if lsn is not None:
            query_parameters['lsn'] = self._serialize.query("lsn", lsn, 'str')
        if recovery_fork_guid is not None:
            query_parameters['recovery_fork_guid'] = self._serialize.query("recovery_fork_guid", recovery_fork_guid, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlRestoreEstimateResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def mssql_get_restore_files(
            self, id, time=None, lsn=None, recovery_fork_guid=None, custom_headers=None, raw=False, **operation_config):
        """Get all database files to be restored.

        Provides a list of database files to be restored for the specified
        restore or export operation.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param time: Time to recover to, in ISO8601 date-time format, such as
         "2016-01-01T01:23:45.678". Either this or the LSN must be specified.
        :type time: datetime
        :param lsn: LSN to recover to. Either this or time must be specified.
        :type lsn: str
        :param recovery_fork_guid: Recovery fork GUID of LSN to recover to.
         Has meaning only when lsn is specified.
        :type recovery_fork_guid: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`MssqlRestoreFile
         <rubriklib_int.models.MssqlRestoreFile>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`MssqlRestoreFile
         <rubriklib_int.models.MssqlRestoreFile>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/{id}/restore_files'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if time is not None:
            query_parameters['time'] = self._serialize.query("time", time, 'iso-8601')
        if lsn is not None:
            query_parameters['lsn'] = self._serialize.query("lsn", lsn, 'str')
        if recovery_fork_guid is not None:
            query_parameters['recovery_fork_guid'] = self._serialize.query("recovery_fork_guid", recovery_fork_guid, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[MssqlRestoreFile]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def mssql_get_snappable_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get the snappableId for a Microsoft SQL database.

        Returns the snappableId for a Microsoft SQL database.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlSnappableId
         <rubriklib_int.models.MssqlSnappableId>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlSnappableId
         <rubriklib_int.models.MssqlSnappableId>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/db/{id}/snappable_id'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlSnappableId', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def count_mssql_instance(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a count of Microsoft SQL instances.

        Returns a count of all Microsoft SQL instances.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/mssql/instance/count'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nodes(
            self, custom_headers=None, raw=False, **operation_config):
        """Get list of nodes in this Rubrik cluster.

        Returns the list of all Rubrik nodes.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`NodeStatus <rubriklib_int.models.NodeStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`NodeStatus <rubriklib_int.models.NodeStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[NodeStatus]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_node(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Detailed view of a Rubrik node.

        Returns the complete view of a Rubrik node.

        :param id: ID of the node to load
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeInfo <rubriklib_int.models.NodeInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeInfo <rubriklib_int.models.NodeInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NodeInfo', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_node_cpu_cores_count(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get CPU Cores count of a node.

        CPU cores count of a node.

        :param id: Id of the node to get cpu cores count for.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}/cpu_cores_count'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_node_io(
            self, id, range=None, custom_headers=None, raw=False, **operation_config):
        """Iops and IO throughput of the node.

        Iops and IO throughput of the node.

        :param id: Id of node to fetch IO throughput stats for
        :type id: str
        :param range: Optional time range parameter for the timeseries, eg:
         -1h, -1min, etc. Default value is -6h
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`IoStat <rubriklib_int.models.IoStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`IoStat <rubriklib_int.models.IoStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}/io_stats'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('IoStat', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_node_stats(
            self, id, range=None, custom_headers=None, raw=False, **operation_config):
        """Fetches time ranged statistics about the specified Node.

        Statistics about the specific Node given a time range. One hour is
        default.

        :param id: Id of the node to fetch statistics for
        :type id: str
        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NodeStats <rubriklib_int.models.NodeStats>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NodeStats <rubriklib_int.models.NodeStats>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}/stats'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NodeStats', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def configure_interface(
            self, id, network_interface, custom_headers=None, raw=False, **operation_config):
        """Adds or re-ips a VLAN on the node.

        Edits tagged interfaces on the node by VLAN.

        :param id: Id of node to add VLAN interface to
        :type id: str
        :param network_interface: Network interface to apply
        :type network_interface: :class:`NetworkInterface
         <rubriklib_int.models.NetworkInterface>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}/vlan'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(network_interface, 'NetworkInterface')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_interface(
            self, id, vlan, custom_headers=None, raw=False, **operation_config):
        """Drops a VLAN interface from the node.

        Drops the specified VLAN interface from the node.

        :param id: Id of node to remove VLAN interface from
        :type id: str
        :param vlan: VLAN
        :type vlan: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}/vlan'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['vlan'] = self._serialize.query("vlan", vlan, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_interfaces(
            self, id, vlan=None, custom_headers=None, raw=False, **operation_config):
        """Get configured VLAN interfaces on node.

        Retrieves the VLANs configured on node and their ip configurations.

        :param id: Id of node to remove retrieve VLAN interface info for
        :type id: str
        :param vlan: Will retrieve info for a specific VLAN if passed in
        :type vlan: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`NodeNetworkInterface
         <rubriklib_int.models.NodeNetworkInterface>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`NodeNetworkInterface
         <rubriklib_int.models.NodeNetworkInterface>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node/{id}/vlan'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if vlan is not None:
            query_parameters['vlan'] = self._serialize.query("vlan", vlan, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[NodeNetworkInterface]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def failure_tolerance_status_method(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get Rubrik cluster failure tolerance information.

        Return various numbers of component failures allowed in the Rubrik
        cluster under which the cluster remains fully functional.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FailureToleranceStatus
         <rubriklib_int.models.FailureToleranceStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FailureToleranceStatus
         <rubriklib_int.models.FailureToleranceStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/cluster/{id}/failure_tolerance'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FailureToleranceStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_ips(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of a cluster's always-available Ips.

        Get a list of a cluster's always-available Ips.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/cluster_ip'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_cluster_ips(
            self, new_cluster_ips, custom_headers=None, raw=False, **operation_config):
        """Modify the list of cluster IPs.

        Modify the list of cluster IPs.

        :param new_cluster_ips: New list of cluster IPs
        :type new_cluster_ips: list of str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterIpRec <rubriklib_int.models.ClusterIpRec>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterIpRec <rubriklib_int.models.ClusterIpRec>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/cluster_ip'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(new_cluster_ips, '[str]')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterIpRec', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_ip_owner(
            self, ip, custom_headers=None, raw=False, **operation_config):
        """Get the node which owns the cluster IP address.

        Returns the node which owns provided cluster IP address. Returns 'NOT
        OWNED' if the IP is not owned by any node.

        :param ip: cluster IP for which owner needs to be fetched
        :type ip: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/cluster_ip/{ip}'
        path_format_arguments = {
            'ip': self._serialize.url("ip", ip, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_hostname(
            self, custom_headers=None, raw=False, **operation_config):
        """hostname supporting the current server.

        hostname supporting the current server.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/hostname'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def is_bootstrapped(
            self, custom_headers=None, raw=False, **operation_config):
        """Returns whether this machine is bootstrapped to a cluster.

        Check whether this machine has been bootstrapped.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BooleanResponse
         <rubriklib_int.models.BooleanResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/is_bootstrapped'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BooleanResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_management_ip_config(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the management ip's netmask and gateway for this machine's cluster.

        Get the management ip's netmask and gateway for this machine's cluster.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterIpConfig
         <rubriklib_int.models.ClusterIpConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterIpConfig
         <rubriklib_int.models.ClusterIpConfig>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/management_ip'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterIpConfig', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_proxy_configs(
            self, custom_headers=None, raw=False, **operation_config):
        """Get existing proxy settings.

        Get existing proxy settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ProxyConfigGet <rubriklib_int.models.ProxyConfigGet>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ProxyConfigGet <rubriklib_int.models.ProxyConfigGet>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/proxy_config'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProxyConfigGet', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_proxy_config(
            self, proxy, custom_headers=None, raw=False, **operation_config):
        """Update proxy config.

        Update proxy config.

        :param proxy: Proxy url and port
        :type proxy: :class:`ProxyConfig <rubriklib_int.models.ProxyConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ProxyConfigGet <rubriklib_int.models.ProxyConfigGet>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ProxyConfigGet <rubriklib_int.models.ProxyConfigGet>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/proxy_config'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(proxy, 'ProxyConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProxyConfigGet', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_proxy_config(
            self, custom_headers=None, raw=False, **operation_config):
        """Delete existing proxy configuration.

        Delete an existing proxy that was configured.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/proxy_config'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 404:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def replace_node_status_method(
            self, request_id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Returns the status of the corresponding
        replaceNode request.

        REQUIRES SUPPORT TOKEN - Returns the status of the corresponding
        replaceNode request. A support token is required for this operation.

        :param request_id: Replace node request id
        :type request_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplaceNodeStatus
         <rubriklib_int.models.ReplaceNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplaceNodeStatus
         <rubriklib_int.models.ReplaceNodeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/replace_node'

        # Construct parameters
        query_parameters = {}
        query_parameters['request_id'] = self._serialize.query("request_id", request_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplaceNodeStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def replace_node(
            self, replace_node_config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Replace a removed node with a new node,
        keeping HDDs and IPs.

        REQUIRES SUPPORT TOKEN - Replace a removed node with a new node. A
        support token is required for this operation.

        :param replace_node_config: IDs of new node and node to replace
        :type replace_node_config: :class:`ReplaceNodeConfig
         <rubriklib_int.models.ReplaceNodeConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplaceNodeRec <rubriklib_int.models.ReplaceNodeRec>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplaceNodeRec <rubriklib_int.models.ReplaceNodeRec>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/replace_node'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(replace_node_config, 'ReplaceNodeConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplaceNodeRec', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reset_node(
            self, custom_headers=None, raw=False, **operation_config):
        """Issues a reset to the current node.

        Issues a reset to the current node.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/reset'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_routes(
            self, custom_headers=None, raw=False, **operation_config):
        """Get all existing route configs.

        Lists all existing route configs.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/route_config'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[RouteConfig]', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_route(
            self, route_config, custom_headers=None, raw=False, **operation_config):
        """Add a new route config to all hosts.

        Add a new route config to all hosts.

        :param route_config: Network, netmask and gateway
        :type route_config: :class:`RouteConfig
         <rubriklib_int.models.RouteConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/route_config'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(route_config, 'RouteConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('RouteConfig', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_route(
            self, route_config, custom_headers=None, raw=False, **operation_config):
        """Delete an existing route.

        Delete an existing route that was configured.

        :param route_config: Network and netmask
        :type route_config: :class:`RouteDeletionConfig
         <rubriklib_int.models.RouteDeletionConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/route_config'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(route_config, 'RouteDeletionConfig')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)
        if response.status_code == 404:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def fetch_upgrade_status_method(
            self, id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Return fetch upgrade package request status.

        REQUIRES SUPPORT TOKEN - Returns the status of the fetch upgrade
        package request, which is initiated by fetch_package POST. A support
        token is required for this operation.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FetchUpgradeStatus
         <rubriklib_int.models.FetchUpgradeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FetchUpgradeStatus
         <rubriklib_int.models.FetchUpgradeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/{id}/fetch_package'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FetchUpgradeStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def fetch_upgrade(
            self, id, url, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Initiate download of rubrik upgrade package
        from http server.

        REQUIRES SUPPORT TOKEN - Fetch a package for software upgrade from a
        remote http server given the url, use the node_management/{id}/upgrade
        endpoint to initiate upgrade. A support token is required for this
        operation.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param url: URL of location where the upgrade package is hosted
        :type url: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/{id}/fetch_package'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(url, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def upgrade_status_method(
            self, id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Get upgrade request status.

        REQUIRES SUPPORT TOKEN - Returns the status of the upgrade request,
        which is initiated by the POST endpoint. A support token is required
        for this operation.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UpgradeStatus <rubriklib_int.models.UpgradeStatus>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UpgradeStatus <rubriklib_int.models.UpgradeStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/{id}/upgrade'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UpgradeStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def upgrade(
            self, id, upgrade_request=None, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Initiate upgrade using package downloaded from
        remote http server.

        REQUIRES SUPPORT TOKEN - Runs upgrade with the package downloaded from
        remote http server, use the node_management/{id}/fetch_upgrade endpoint
        to fetch upgrade package. A support token is required for this
        operation.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param upgrade_request:  Force defaults to be false. Allows software
         to use an upgrade package of lower or equal version, which is not
         allowed by if force is not specified
        :type upgrade_request: :class:`UpgradeRequest
         <rubriklib_int.models.UpgradeRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/node_management/{id}/upgrade'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if upgrade_request is not None:
            body_content = self._serialize.body(upgrade_request, 'UpgradeRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_nutanix_cluster(
            self, primary_cluster_id=None, should_get_status=None, custom_headers=None, raw=False, **operation_config):
        """Get list of Nutanix clusters.

        Retrieve information for each managed Nutanix cluster.

        :param primary_cluster_id: Limits the information to the Rubrik
         cluster specified by the value of primary_cluster_id. Use 'local' for
         the Rubrik cluster that is hosting the current REST API session.
        :type primary_cluster_id: str
        :param should_get_status: Determines whether or not the status field
         is populated. Populating this field involves issuing a call to the
         Nutanix cluster itself, which may not be performant. Defaults to
         false.
        :type should_get_status: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixClusterSummaryListResponse
         <rubriklib_int.models.NutanixClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixClusterSummaryListResponse
         <rubriklib_int.models.NutanixClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if should_get_status is not None:
            query_parameters['should_get_status'] = self._serialize.query("should_get_status", should_get_status, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixClusterSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_nutanix_cluster(
            self, nutanix_cluster_config, custom_headers=None, raw=False, **operation_config):
        """Add Nutanix cluster.

        Create a Nutanix cluster object by providing an address and account
        credentials for Prism. Initiates an asynchronous job to establish a
        connection with the cluster and retrieve all metadata. Use GET
        /nutanix_cluster/{id}/status to check status.

        :param nutanix_cluster_config: IP address, natural ID of added cluster
         (since Prism central can manage multiple clusters), and credentials
         for Prism.
        :type nutanix_cluster_config: :class:`NutanixClusterConfig
         <rubriklib_int.models.NutanixClusterConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(nutanix_cluster_config, 'NutanixClusterConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_cluster_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get Nutanix cluster async request.

        Get details about a Nutanix cluster-related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_cluster(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get the details of a Nutanix Cluster.

        Retrieve detailed information for a Nutanix Cluster object.

        :param id: ID of the Nutanix Cluster.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixClusterDetail
         <rubriklib_int.models.NutanixClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixClusterDetail
         <rubriklib_int.models.NutanixClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixClusterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def patch_nutanix_cluster(
            self, id, patch_properties, custom_headers=None, raw=False, **operation_config):
        """Patch Nutanix cluster.

        Patch the host, credentials, and/or CA certs of the specified Nutanix
        cluster object.

        :param id: ID of the Nutanix cluster.
        :type id: str
        :param patch_properties: Object containing updated Nutanix cluster
         information.
        :type patch_properties: :class:`NutanixClusterPatch
         <rubriklib_int.models.NutanixClusterPatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixClusterDetail
         <rubriklib_int.models.NutanixClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixClusterDetail
         <rubriklib_int.models.NutanixClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(patch_properties, 'NutanixClusterPatch')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixClusterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_nutanix_cluster(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Remove Nutanix cluster.

        Initiates an asynchronous job to remove a Nutanix cluster object. The
        Nutanix cluster cannot have VMs mounted through the Rubrik cluster.

        :param id: ID of the Nutanix cluster to remove.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_containers(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get list of containers on this cluster.

        Query the nutanix cluster to get the list of containers, used for
        export purposes.

        :param id: ID of the Nutanix cluster
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixContainerListResponse
         <rubriklib_int.models.NutanixContainerListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixContainerListResponse
         <rubriklib_int.models.NutanixContainerListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster/{id}/container'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixContainerListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_nutanix_cluster_refresh(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Refresh Nutanix cluster metadata.

        Create a job to refresh the metadata for the specified Nutanix cluster.

        :param id: ID of the Nutanix cluster
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/cluster/{id}/refresh'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_hierarchy_object(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary of a hierarchy object.

        Retrieve details for the specified hierarchy object.

        :param id: ID of the hierarchy object
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixHierarchyObjectSummary
         <rubriklib_int.models.NutanixHierarchyObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixHierarchyObjectSummary
         <rubriklib_int.models.NutanixHierarchyObjectSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/hierarchy/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixHierarchyObjectSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_hierarchy_children(
            self, id, effective_sla_domain_id=None, object_type=None, primary_cluster_id=None, is_relic=None, limit=None, offset=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of immediate descendant objects.

        Retrieve the list of immediate descendant objects for the specified
        parent.

        :param id: ID of the parent Nutanix hierarchy object. To get top-level
         nodes, use **root** as the ID.
        :type id: str
        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param object_type: Filter by node object type
        :type object_type: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param is_relic: Filter by isRelic field of Nutanix VM hierarchy
         object. Return both relic and non-relic children if this query is not
         set.
        :type is_relic: bool
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Attribute to sort the results on. Possible values
         include: 'effectiveSlaDomainName', 'name', 'descendantCount.cluster',
         'descendantCount.vm'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixHierarchyObjectSummaryListResponse
         <rubriklib_int.models.NutanixHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixHierarchyObjectSummaryListResponse
         <rubriklib_int.models.NutanixHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/hierarchy/{id}/children'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixHierarchyObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_hierarchy_descendants(
            self, id, effective_sla_domain_id=None, object_type=None, primary_cluster_id=None, is_relic=None, limit=None, offset=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of descendant objects.

        Retrieve the list of descendant objects for the specified parent.

        :param id: ID of the parent Nutanix hierarchy object
        :type id: str
        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param object_type: Filter by node object type. Possible values
         include: 'cluster', 'vm'
        :type object_type: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param is_relic: Filter by isRelic field of Nutanix VM hierarchy
         object. Return both relic and non-relic children if this query is not
         set.
        :type is_relic: bool
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Attribute to sort the results on. Possible values
         include: 'effectiveSlaDomainName', 'name', 'descendantCount.cluster',
         'descendantCount.vm'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixHierarchyObjectSummaryListResponse
         <rubriklib_int.models.NutanixHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixHierarchyObjectSummaryListResponse
         <rubriklib_int.models.NutanixHierarchyObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/hierarchy/{id}/descendants'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixHierarchyObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_nutanix_vm(
            self, effective_sla_domain_id=None, primary_cluster_id=None, limit=None, offset=None, is_relic=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of Nutanix VMs.

        Get summary of all the VMs.

        :param effective_sla_domain_id: Filter by ID of effective SLA domain
        :type effective_sla_domain_id: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param is_relic: Filter by isRelic field of VM. Return both relic and
         non-relic VM if this query is not set.
        :type is_relic: bool
        :param name: Search vm by vm name.
        :type name: str
        :param sla_assignment: Filter by SLA assignment type. Possible values
         include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Attribute to sort the results on. Possible values
         include: 'effectiveSlaDomainName', 'name', 'folderPath', 'infraPath'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixVmSummaryListResponse
         <rubriklib_int.models.NutanixVmSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixVmSummaryListResponse
         <rubriklib_int.models.NutanixVmSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm'

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixVmSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_vm_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM async request details.

        Get details about a Nutanix VM-related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM snapshot details.

        Retrieve detailed information about a snapshot.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixVmSnapshotDetail
         <rubriklib_int.models.NutanixVmSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixVmSnapshotDetail
         <rubriklib_int.models.NutanixVmSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixVmSnapshotDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_nutanix_snapshot(
            self, id, location, custom_headers=None, raw=False, **operation_config):
        """Delete VM snapshot.

        Delete a snapshot by expiring it. Snapshot is expired only if it is a
        manual snapshot or a snapshot of an unprotected vm.

        :param id: ID of snapshot
        :type id: str
        :param location: Snapshot location to delete. Use **_local_** to
         delete all local snapshots and **_all_** to delete the snapshot in all
         locations. Possible values include: 'all', 'local'
        :type location: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['location'] = self._serialize.query("location", location, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def browse_nutanix_snapshot(
            self, id, path, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Lists all files in VM snapshot.

        Lists all files and directories in a given path.

        :param id: ID of snapshot
        :type id: str
        :param path: The absolute path of the starting point for the directory
         listing.
        :type path: str
        :param offset: Starting position in the list of path entries contained
         in the query results, sorted by lexicographical order. The response
         includes the specified numbered entry and all higher numbered entries.
        :type offset: int
        :param limit: Maximum number of entries in the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BrowseResponseListResponse
         <rubriklib_int.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/snapshot/{id}/browse'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BrowseResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_download_snapshot_from_cloud(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Creates a download from archival request.

        Download a snapshot from archival.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/snapshot/{id}/download'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_nutanix_download_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Download file from VM snapshot.

        Create a download file request.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for a download request
        :type config: :class:`NutanixDownloadFileJobConfig
         <rubriklib_int.models.NutanixDownloadFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/snapshot/{id}/download_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'NutanixDownloadFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_nutanix_export(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Export VM snapshot.

        Export snapshot of a vm.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for the export request
        :type config: :class:`NutanixVmExportSnapshotJobConfig
         <rubriklib_int.models.NutanixVmExportSnapshotJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/snapshot/{id}/export'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'NutanixVmExportSnapshotJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_nutanix_vm(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM details.

        Detailed view of a Nutanix VM.

        :param id: ID of the Nutanix Virtual Machine.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixVmDetail
         <rubriklib_int.models.NutanixVmDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixVmDetail
         <rubriklib_int.models.NutanixVmDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixVmDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def patch_nutanix_vm(
            self, id, vm_patch_properties, custom_headers=None, raw=False, **operation_config):
        """Patch VM.

        Patch VM with specified properties.

        :param id: ID of Nutanix Virtual Machine
        :type id: str
        :param vm_patch_properties: Properties to patch
        :type vm_patch_properties: :class:`NutanixVmPatch
         <rubriklib_int.models.NutanixVmPatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixVmDetail
         <rubriklib_int.models.NutanixVmDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixVmDetail
         <rubriklib_int.models.NutanixVmDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(vm_patch_properties, 'NutanixVmPatch')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixVmDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def nutanix_missed_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about missed snapshots for a VM.

        Retrieve the time of the day when the snapshots were missed specific to
        a vm.

        :param id: ID of the vm
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MissedSnapshotListResponse
         <rubriklib_int.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MissedSnapshotListResponse
         <rubriklib_int.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}/missed_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MissedSnapshotListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def search_nutanix_vm(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for file in Nutanix VM.

        Search for a file within the Nutanix Virtual Machine. Search via full
        path prefix or filename prefix.

        :param id: ID of the vm
        :type id: str
        :param path: The path query. Either path prefix or filename prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_nutanix_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get list of snapshots of VM.

        Retrieve the following information for all snapshots for a VM: ID,
        snapshot date, expiration date, type of source object, name of VM, type
        of snapshot, state of the cloud, level of consistency, name of snapshot
        VM, index state, total number of files, IDs of all replication
        location, IDs of all archival locations.

        :param id: ID of the vm
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`NutanixVmSnapshotSummaryListResponse
         <rubriklib_int.models.NutanixVmSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`NutanixVmSnapshotSummaryListResponse
         <rubriklib_int.models.NutanixVmSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NutanixVmSnapshotSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_on_demand_nutanix_backup(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Create on-demand VM snapshot.

        Create an on-demand snapshot for the given VM ID.

        :param id: ID of the VM
        :type id: str
        :param config: Configuration for the on-demand backup.
        :type config: :class:`BaseOnDemandSnapshotConfig
         <rubriklib_int.models.BaseOnDemandSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'BaseOnDemandSnapshotConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_nutanix_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete all snapshots of VM.

        Delete all snapshots of a virtual machine.

        :param id: Virtual machine ID
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/nutanix/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def search_principals(
            self, search_request, custom_headers=None, raw=False, **operation_config):
        """Searches for security principals.

        Searches for security principals using one or more independent queries.
        The result set is the union of the principals returned by each query.

        :param search_request: Search request to perform
        :type search_request: :class:`PrincipalSearchRequest
         <rubriklib_int.models.PrincipalSearchRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`PrincipalSummaryListResponse
         <rubriklib_int.models.PrincipalSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`PrincipalSummaryListResponse
         <rubriklib_int.models.PrincipalSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/principal_search'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(search_request, 'PrincipalSearchRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PrincipalSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def replication_sources(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summaries for all replication sources.

        Retrieve the ID, name, and address for each replication source.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplicationSourceSummaryListResponse
         <rubriklib_int.models.ReplicationSourceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplicationSourceSummaryListResponse
         <rubriklib_int.models.ReplicationSourceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/source'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplicationSourceSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_replication_source(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary for a specific replication source.

        Retrieve the ID, name, and address for a specified replication source.

        :param id: ID of a replication source.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplicationSourceSummary
         <rubriklib_int.models.ReplicationSourceSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplicationSourceSummary
         <rubriklib_int.models.ReplicationSourceSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/source/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplicationSourceSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_replication_source(
            self, id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN: Remove a replication source.

        REQUIRES SUPPORT TOKEN: Remove a specified replication source from this
        Rubrik cluster. A support token is required for this operation.

        :param id: ID of the replication source to be removed.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DeleteReplicationSourceSummary
         <rubriklib_int.models.DeleteReplicationSourceSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DeleteReplicationSourceSummary
         <rubriklib_int.models.DeleteReplicationSourceSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/source/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DeleteReplicationSourceSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def replication_targets(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summary of current replication target.

        Retrieve the ID, name, and address for the current replication target.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplicationTargetSummaryListResponse
         <rubriklib_int.models.ReplicationTargetSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplicationTargetSummaryListResponse
         <rubriklib_int.models.ReplicationTargetSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/target'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplicationTargetSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_replication_target(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Configure a replication target.

        Provide an address, network setup, username, and password to configure
        and enable a replication target. Network setup must be either 'NAT' or
        'Private Network'. WARNING: This will fail if there is already an
        existing replication target.

        :param definition: Replication target definition
        :type definition: :class:`ReplicationTargetDefinition
         <rubriklib_int.models.ReplicationTargetDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/target'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'ReplicationTargetDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('ReplicationTargetSummary', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_replication_target(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary for the replication target.

        Retrieve the ID, name, and address of the replication target.

        :param id: ID of the replication target.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplicationTargetSummary
         <rubriklib_int.models.ReplicationTargetSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplicationTargetSummary
         <rubriklib_int.models.ReplicationTargetSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/target/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplicationTargetSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_replication_target(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Remove the replication target.

        Remove the replication target from this cluster.

        :param id: ID of the replication target.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/target/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_replication_target(
            self, id, update, custom_headers=None, raw=False, **operation_config):
        """Update the replication target information.

        Update the setup information, address, username, and password for the
        replication target.

        :param id: ID of the replication target.
        :type id: str
        :param update: Object containing updated replication target
         information.
        :type update: :class:`ReplicationTargetDefinition
         <rubriklib_int.models.ReplicationTargetDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplicationTargetSummary
         <rubriklib_int.models.ReplicationTargetSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplicationTargetSummary
         <rubriklib_int.models.ReplicationTargetSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/replication/target/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'ReplicationTargetDefinition')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplicationTargetSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_reports(
            self, report_type=None, search_text=None, sort_attr=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all reports.

        Retrieve summary information for each report. Optionally, filter the
        retrieved information.

        :param report_type: Filter the returned reports based off the reports
         type. Possible values include: 'Canned', 'Custom'
        :type report_type: str
        :param search_text: Filter the returned reports based off their name
        :type search_text: str
        :param sort_attr: Sort the returned reports based off the specified
         attribute. Default: Name. Possible values include: 'Name',
         'ReportType'
        :type sort_attr: str
        :param sort_order: Order by which to sort the returned reports.
         Default: asc. Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReportSummaryListResponse
         <rubriklib_int.models.ReportSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReportSummaryListResponse
         <rubriklib_int.models.ReportSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report'

        # Construct parameters
        query_parameters = {}
        if report_type is not None:
            query_parameters['report_type'] = self._serialize.query("report_type", report_type, 'str')
        if search_text is not None:
            query_parameters['search_text'] = self._serialize.query("search_text", search_text, 'str')
        if sort_attr is not None:
            query_parameters['sort_attr'] = self._serialize.query("sort_attr", sort_attr, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_report(
            self, report_config, custom_headers=None, raw=False, **operation_config):
        """Create a new report.

        Create a new report by specifying one of the report templates.

        :param report_config: Report name and Report template
        :type report_config: :class:`ReportCreate
         <rubriklib_int.models.ReportCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReportDetail <rubriklib_int.models.ReportDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReportDetail <rubriklib_int.models.ReportDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(report_config, 'ReportCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('ReportDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_single_email_subscription(
            self, subscription_id, custom_headers=None, raw=False, **operation_config):
        """Returns specific email subscription for a report.

        Returns the email subscription specified by subscription_id for the
        report it is a subscription of.

        :param subscription_id: Id of the specific email seubscription to
         retrieve
        :type subscription_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/email_subscription/{subscription_id}'
        path_format_arguments = {
            'subscription_id': self._serialize.url("subscription_id", subscription_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EmailSubscriptionSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_email_subscription(
            self, subscription_id, subscribe_request, custom_headers=None, raw=False, **operation_config):
        """Updates a specific email subscription for a report.

        Updates the email subscription specified by subscription_id for the
        report it is a subscription of.

        :param subscription_id: Id of the specific email seubscription to
         retrieve
        :type subscription_id: str
        :param subscribe_request: Definition of the updated email
         subscription.
        :type subscribe_request: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/email_subscription/{subscription_id}'
        path_format_arguments = {
            'subscription_id': self._serialize.url("subscription_id", subscription_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(subscribe_request, 'EmailSubscriptionSummary')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EmailSubscriptionSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_email_subscription(
            self, subscription_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specific email subscription for a report.

        Deletes the email subscription specified by subscription_id for the
        report it is a subscription of.

        :param subscription_id: Id of the specific email seubscription to
         retrieve
        :type subscription_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/email_subscription/{subscription_id}'
        path_format_arguments = {
            'subscription_id': self._serialize.url("subscription_id", subscription_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_report(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information about a specific report.

        Get report details and update status.

        :param id: ID of the report
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReportDetail <rubriklib_int.models.ReportDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReportDetail <rubriklib_int.models.ReportDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_report(
            self, id, update_config, custom_headers=None, raw=False, **operation_config):
        """Update a specific report.

        Update a specific report. The report's name, chart parameters, filters
        and table can be updated. If successful, this will automatically
        trigger an async job to refresh the report content.

        :param id: ID of the report
        :type id: str
        :param update_config: Report update config
        :type update_config: :class:`ReportUpdate
         <rubriklib_int.models.ReportUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReportDetail <rubriklib_int.models.ReportDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReportDetail <rubriklib_int.models.ReportDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_config, 'ReportUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReportDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_report(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a specific report.

        Delete a specific report specified by reportId.

        :param id: ID of the report
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_charts(
            self, id, chart_id=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Get chart data for a report.

        Retrieve chart data associated with the report specified by id.

        :param id: ID of the report
        :type id: str
        :param chart_id: ID of the chart
        :type chart_id: str
        :param limit: Maximum number of chart columns to return
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`ChartData <rubriklib_int.models.ChartData>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`ChartData <rubriklib_int.models.ChartData>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}/chart'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if chart_id is not None:
            query_parameters['chart_id'] = self._serialize.query("chart_id", chart_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ChartData]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_csv_download_link(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get a CSV file for the report specified by id.

        Get the link to a CSV file for a report. This is a synchronous
        operation.

        :param id: ID of the report
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}/download_csv'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_email_subscriptions(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Returns email subscriptions for a report.

        Returns all email subscriptions for the report specified by id.

        :param id: Id of the report to get email subscriptions for
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}/email_subscription'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EmailSubscriptionSummary]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_email_subscription(
            self, id, subscribe_request, custom_headers=None, raw=False, **operation_config):
        """Creates email subscription for a report.

        Creates an email subscription for the report specified by id.

        :param id: Id of the report to create an email subscription for.
        :type id: str
        :param subscribe_request: Definition of the email subscription to
         create.
        :type subscribe_request: :class:`EmailSubscriptionCreate
         <rubriklib_int.models.EmailSubscriptionCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`EmailSubscriptionSummary
         <rubriklib_int.models.EmailSubscriptionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}/email_subscription'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(subscribe_request, 'EmailSubscriptionCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EmailSubscriptionSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def refresh_report_data(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Begins to refresh the data associated with a report.

        Begins to refresh the data associated with the report specified by id.
        This should be used following calls to the various report patch
        endpoints in order to trigger the data update.

        :param id: Id of the report to refresh
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}/refresh'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_table(
            self, id, limit=None, sort_attr=None, sort_order=None, after_id=None, search_value=None, sla_domain_id=None, task_type=None, task_status=None, object_type=None, compliance_status=None, cluster_location=None, custom_headers=None, raw=False, **operation_config):
        """Gets the table associated with the report specified by id.

        Retrieve table data for a specific report.

        :param id: ID of the report
        :type id: str
        :param limit: Maximum number of table rows to return.
        :type limit: int
        :param sort_attr: Sort the returned table based off the specified
         attribute. Possible values include: 'ObjectName', 'ObjectType',
         'Location', 'ClusterLocation', 'SlaDomain', 'TaskType', 'TaskStatus',
         'Hour', 'Day', 'Month', 'Quarter', 'Year', 'QueuedTime', 'StartTime',
         'EndTime', 'Duration', 'DataTransferred', 'LogicalDataProtected',
         'DataStored', 'DedupRatio', 'LogicalDedupRatio',
         'DataReductionPercent', 'LogicalDataReductionPercent', 'TaskCount',
         'SuccessfulTasks', 'CanceledTasks', 'FailedTasks', 'RunningTasks',
         'AverageDuration', 'ObjectCount', 'TotalLocalStorage',
         'TotalReplicaStorage', 'TotalArchiveStorage', 'LocalStorageGrowth',
         'ArchiveStorageGrowth', 'ReplicaStorageGrowth', 'ProtectedOn',
         'InComplianceCount', 'NonComplianceCount', 'TotalSnapshots',
         'MissedSnapshots', 'LocalSnapshots', 'ReplicaSnapshots',
         'ArchiveSnapshots', 'LastSnapshot'
        :type sort_attr: str
        :param sort_order: Order by which to sort the returned table. Default:
         asc. Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param after_id: Fetches all rows after given id.
        :type after_id: str
        :param search_value: Search table data by object name.
        :type search_value: str
        :param sla_domain_id: Filter table data on SLA domain id.
        :type sla_domain_id: str
        :param task_type: Filter table data on task type.
        :type task_type: str
        :param task_status: Filter table data on task status.
        :type task_status: str
        :param object_type: Filter table data on object type.
        :type object_type: str
        :param compliance_status: Filter table data on compliance status.
        :type compliance_status: str
        :param cluster_location: Filter table data on cluster location.
        :type cluster_location: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`TableData <rubriklib_int.models.TableData>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`TableData <rubriklib_int.models.TableData>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/report/{id}/table'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if sort_attr is not None:
            query_parameters['sort_attr'] = self._serialize.query("sort_attr", sort_attr, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')
        if after_id is not None:
            query_parameters['after_id'] = self._serialize.query("after_id", after_id, 'str')
        if search_value is not None:
            query_parameters['search_value'] = self._serialize.query("search_value", search_value, 'str')
        if sla_domain_id is not None:
            query_parameters['sla_domain_id'] = self._serialize.query("sla_domain_id", sla_domain_id, 'str')
        if task_type is not None:
            query_parameters['task_type'] = self._serialize.query("task_type", task_type, 'str')
        if task_status is not None:
            query_parameters['task_status'] = self._serialize.query("task_status", task_status, 'str')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')
        if compliance_status is not None:
            query_parameters['compliance_status'] = self._serialize.query("compliance_status", compliance_status, 'str')
        if cluster_location is not None:
            query_parameters['cluster_location'] = self._serialize.query("cluster_location", cluster_location, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TableData', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def search_query(
            self, managed_id, query_string, custom_headers=None, raw=False, **operation_config):
        """Search for a file within the given managed ID of a Virtual Machine or
        Fileset or Host.

        Search for a file within a given VM or Host. Search via full path
        prefix or filename prefix.

        :param managed_id: Managed ID of the object that is searched. It has
         to be either a Virtual Machine or Fileset or Host.
        :type managed_id: str
        :param query_string: The query string. Either path prefix or filename
         prefix
        :type query_string: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib_int.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/search'

        # Construct parameters
        query_parameters = {}
        query_parameters['managed_id'] = self._serialize.query("managed_id", managed_id, 'str')
        query_parameters['query_string'] = self._serialize.query("query_string", query_string, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_sla_conflicts(
            self, managed_id, custom_headers=None, raw=False, **operation_config):
        """Finding managed entities with SLA Domain conflicts.

        Find managed entities that have a conflict with the SLA Domain
        assignment that is derived from a specified entity. For managed
        entities that derive an assignment from the specified entity, this call
        finds conflicts caused by an individual assignment, and conflicts
        caused by deriving assignments from more than one source.

        :param managed_id: ID of the managed entity that is the source of the
         derived SLA Domain assignment. All entities that derive an SLA Domain
         assignment from the specified managed entity are checked for
         conflicts.
        :type managed_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ProtectionDetailListResponse
         <rubriklib_int.models.ProtectionDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ProtectionDetailListResponse
         <rubriklib_int.models.ProtectionDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/sla_domain/conflicts'

        # Construct parameters
        query_parameters = {}
        query_parameters['managed_id'] = self._serialize.query("managed_id", managed_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ProtectionDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def assign_to_sla_and_wait_for_job(
            self, id, assignment_info, custom_headers=None, raw=False, **operation_config):
        """Assign managed entities to an SLA Domain synchronously.

        Assign managed entities to the specified SLA Domain. The assignment
        event runs synchronously.

        :param id: ID of the SLA Domain.
        :type id: str
        :param assignment_info: A comma-separated list of the IDs of the
         managed entities being assigned to the SLA Domain.
        :type assignment_info: :class:`SlaDomainAssignmentInfo
         <rubriklib_int.models.SlaDomainAssignmentInfo>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/sla_domain/{id}/assign'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(assignment_info, 'SlaDomainAssignmentInfo')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def create_smtp_instance(
            self, instance, custom_headers=None, raw=False, **operation_config):
        """Add smtp instances.

        Add smtp instances.

        :param instance: smtp instance
        :type instance: :class:`SmtpInstanceDefinition
         <rubriklib_int.models.SmtpInstanceDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SmtpInstanceDetail
         <rubriklib_int.models.SmtpInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SmtpInstanceDetail
         <rubriklib_int.models.SmtpInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/smtp_instance'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(instance, 'SmtpInstanceDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('SmtpInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_smtp_instance(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summary of all smtp instances.

        Get summary of all smtp instances.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SmtpInstanceDetailListResponse
         <rubriklib_int.models.SmtpInstanceDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SmtpInstanceDetailListResponse
         <rubriklib_int.models.SmtpInstanceDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/smtp_instance'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SmtpInstanceDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def send_test_email(
            self, email_ids, custom_headers=None, raw=False, **operation_config):
        """send email.

        Send email to admin users if toEmailIds is empty.

        :param email_ids: send email params
        :type email_ids: :class:`SendEmailParams
         <rubriklib_int.models.SendEmailParams>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/smtp_instance/send_test_email'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(email_ids, 'SendEmailParams')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_smtp_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Details of a smtp instance.

        :param id: ID of the smtp instance to be fetched
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SmtpInstanceDetail
         <rubriklib_int.models.SmtpInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SmtpInstanceDetail
         <rubriklib_int.models.SmtpInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/smtp_instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SmtpInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_smtp_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a smtp instance.

        :param id: ID of the smtp instance to be deleted
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/smtp_instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def update_smtp_instance(
            self, id, instance, custom_headers=None, raw=False, **operation_config):
        """update specifications for sending email.

        update specifications for sending email.

        :param id: ID of the smtp instance to be deleted
        :type id: str
        :param instance: smtp instances
        :type instance: :class:`UpdateSmtpInstanceDefinition
         <rubriklib_int.models.UpdateSmtpInstanceDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SmtpInstanceDetail
         <rubriklib_int.models.SmtpInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SmtpInstanceDetail
         <rubriklib_int.models.SmtpInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/smtp_instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(instance, 'UpdateSmtpInstanceDefinition')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SmtpInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def snapshot_archive_garbage_collection_status(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Check whether snapshots have been GC''d on
        archive.

        REQUIRES SUPPORT TOKEN - Check whether snapshots have been GC''d on
        archive. A support token is required for this operation.

        :param config: List of snapshot IDs and location ID to check if GC'd
        :type config:
         :class:`InternalSnapshotArchiveGarbageCollectStatusConfig
         <rubriklib_int.models.InternalSnapshotArchiveGarbageCollectStatusConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`InternalGarbageCollectStatusResult
         <rubriklib_int.models.InternalGarbageCollectStatusResult>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`InternalGarbageCollectStatusResult
         <rubriklib_int.models.InternalGarbageCollectStatusResult>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/snapshot/archive_garbage_collect_status'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'InternalSnapshotArchiveGarbageCollectStatusConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('InternalGarbageCollectStatusResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def corrupt_snapshot_chain(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Corrupt an incremental snapshot by redirecting
        its base pointer.

        REQUIRES SUPPORT TOKEN- Corrupt an incremental snapshot by redirecting
        its base pointer. CAUTION - This request races with Reverse and Expire,
        so care must be taken to disable these jobs or stop services (on all
        nodes). A support token is required for this operation.

        :param config: Configuration for the snapshot corruption
        :type config: :class:`CorruptSnapshotChainConfig
         <rubriklib_int.models.CorruptSnapshotChainConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/snapshot/corrupt_chain'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'CorruptSnapshotChainConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def internal_expire_snapshot(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Expire a snapshot.

        REQUIRES SUPPORT TOKEN - Will mark the snapshot as expired. A support
        token is required for this operation.

        :param config: ID of the Snapshot that needs to be expired locally
        :type config: :class:`InternalExpireSnapshotConfig
         <rubriklib_int.models.InternalExpireSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/snapshot/expire'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'InternalExpireSnapshotConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 404, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)
        if response.status_code == 404:
            deserialized = self._deserialize('str', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def snapshot_garbage_collection_status(
            self, config, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Check whether snapshots have been GC''d.

        REQUIRES SUPPORT TOKEN - Check whether snapshots have been GC''d. A
        support token is required for this operation.

        :param config: List of snapshot IDs to check if GC'd
        :type config: :class:`InternalSnapshotGarbageCollectStatusConfig
         <rubriklib_int.models.InternalSnapshotGarbageCollectStatusConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`InternalGarbageCollectStatusResult
         <rubriklib_int.models.InternalGarbageCollectStatusResult>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`InternalGarbageCollectStatusResult
         <rubriklib_int.models.InternalGarbageCollectStatusResult>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/snapshot/garbage_collect_status'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'InternalSnapshotGarbageCollectStatusConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('InternalGarbageCollectStatusResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_snapshot_diagnostic_info(
            self, id, snappable_id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Returns the diagnostic info of a snapshot.

        REQUIRES SUPPORT TOKEN - It returns some diagnostic info of a snapshot,
        right now only compression type is returned. A support token is
        required for this operation.

        :param id: ID of the Snapshot to get info from
        :type id: str
        :param snappable_id: Snappable id of target object
        :type snappable_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SnapshotDiagnosticInfo
         <rubriklib_int.models.SnapshotDiagnosticInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SnapshotDiagnosticInfo
         <rubriklib_int.models.SnapshotDiagnosticInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/snapshot/{id}/diagnostic'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['snappable_id'] = self._serialize.query("snappable_id", snappable_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SnapshotDiagnosticInfo', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_snapshot_storage_stats(
            self, id, snappable_id, custom_headers=None, raw=False, **operation_config):
        """REQUIRES SUPPORT TOKEN - Returns storage stats for a snapshot.

        REQUIRES SUPPORT TOKEN - It returns storage stats for a snapshot. This
        end point is not supposed to be ever exposed. A support token is
        required for this operation.

        :param id: ID of the Snapshot to get storage stats from
        :type id: str
        :param snappable_id: Filter by ID of effective SLA domain
        :type snappable_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SnapshotStorageStats
         <rubriklib_int.models.SnapshotStorageStats>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SnapshotStorageStats
         <rubriklib_int.models.SnapshotStorageStats>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/snapshot/{id}/storage/stats'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['snappable_id'] = self._serialize.query("snappable_id", snappable_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SnapshotStorageStats', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def archival_bandwidth(
            self, data_location_id=None, range=None, custom_headers=None, raw=False, **operation_config):
        """Get the bandwidth of the archival location.

        Gets the bandwidth of the archival location. If data location ID is not
        provided, returns the sum over all archival locations.

        :param data_location_id: Data location ID
        :type data_location_id: str
        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/archival/bandwidth/time_series'

        # Construct parameters
        query_parameters = {}
        if data_location_id is not None:
            query_parameters['data_location_id'] = self._serialize.query("data_location_id", data_location_id, 'str')
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def available_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get available storage in cluster.

        Get available storage in cluster.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/available_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def average_storage_growth_per_day(
            self, custom_headers=None, raw=False, **operation_config):
        """Get average storage growth per day.

        Get average storage growth per day.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`StorageGrowth <rubriklib_int.models.StorageGrowth>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`StorageGrowth <rubriklib_int.models.StorageGrowth>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/average_storage_growth_per_day'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('StorageGrowth', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def cloud_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get storage used on cloud for all snapshots.

        Get storage used on cloud for all snapshots.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/cloud_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def cross_compression(
            self, custom_headers=None, raw=False, **operation_config):
        """Get compression stats for cross increments.

        Get compression stats for cross increments.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/cross_compression'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def data_locations_usage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get usage details of al data locations.

        Get usage details from all data locations.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DataLocationUsageListResponse
         <rubriklib_int.models.DataLocationUsageListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DataLocationUsageListResponse
         <rubriklib_int.models.DataLocationUsageListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/data_location/usage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DataLocationUsageListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def logical_ingest(
            self, custom_headers=None, raw=False, **operation_config):
        """Get timeseries on logical data ingestion.

        Get timeseries on logical data ingestion.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/logical_ingest/time_series'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def per_mount_storage(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get storage footprint on rubrik for a given mount.

        Get storage footprint on rubrik for a given mount.

        :param id: Mount ID
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/per_mount_storage/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def all_vm_storage_stats(
            self, custom_headers=None, raw=False, **operation_config):
        """Get total storage consumed by each vm.

        Get total storage storage consumed by each vm sorted by storage. If a
        vm's storage is zero, it is not present in the list.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmStorageStatsListResponse
         <rubriklib_int.models.VmStorageStatsListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmStorageStatsListResponse
         <rubriklib_int.models.VmStorageStatsListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/per_vm_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmStorageStatsListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def per_vm_storage_stats(
            self, vm_id, custom_headers=None, raw=False, **operation_config):
        """Storage consumed by this vm.

        storage storage consumed by this vm.

        :param vm_id: Virtual Machine ID
        :type vm_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmStorageStats <rubriklib_int.models.VmStorageStats>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmStorageStats <rubriklib_int.models.VmStorageStats>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/per_vm_storage/{vm_id}'
        path_format_arguments = {
            'vm_id': self._serialize.url("vm_id", vm_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmStorageStats', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def physical_ingest(
            self, range=None, custom_headers=None, raw=False, **operation_config):
        """Get timeseries on physical data ingestion.

        Get timeseries on physical data ingestion.

        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/physical_ingest/time_series'

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def physical_ingest_per_day(
            self, range=None, custom_headers=None, raw=False, **operation_config):
        """Get a timeseries on physical data ingestion per day.

        Get a timeseries on physical data ingestion per day.

        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/physical_ingest_per_day/time_series'

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def physical_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get total physical storage being used in the system.

        Get total Physical storage being used in the system.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/physical_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def protected_primary_snapshot_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get protected primary storage.

        Get protected primary storage.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/protected_primary_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def replication_bandwidth_incoming(
            self, range=None, custom_headers=None, raw=False, **operation_config):
        """Get a timeseries of total incoming bandwidth from the replication
        clusters.

        Get the total incoming bandwidth from the replication clusters.

        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/replication/incoming/time_series'

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def replication_bandwidth_outgoing(
            self, range=None, custom_headers=None, raw=False, **operation_config):
        """Get the total outgoing bandwidth to the replication clusters.

        Get the total outgoing bandwidth to the replication clusters.

        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/replication/outgoing/time_series'

        # Construct parameters
        query_parameters = {}
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def runway_remaining(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the number of days remaining before the system fills up.

        Get the number of days remaining before the system fills up.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`Runway <rubriklib_int.models.Runway>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`Runway <rubriklib_int.models.Runway>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/runway_remaining'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Runway', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def total_sla_domain_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get total storage for all the SLA domains.

        Get total storage for all the SLA domains.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/sla_domain_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def sla_domain_storage_timeseries(
            self, id, range=None, custom_headers=None, raw=False, **operation_config):
        """Get a timeseries of storage growth for the given SLA domain.

        Get a timeseries of storage growth timeseries for the given SLA domain.

        :param id: SLA Domain ID
        :type id: str
        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/sla_domain_storage/time_series'

        # Construct parameters
        query_parameters = {}
        query_parameters['id'] = self._serialize.query("id", id, 'str')
        if range is not None:
            query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def sla_domain_storage(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get storage used on cloud for the given SLA domain.

        Get storage used on cloud for the given SLA domain.

        :param id: SLA Domain ID
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/sla_domain_storage/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def snapshot_ingest(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a timeseries of snapshots being ingested at a given time instance.

        Get a timeseries of snapshots being ingested at a given time instance.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/snapshot_ingest/time_series'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def ingested_snapshot_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get ingested storage for all snapshots.

        Get ingested storage for all snapshots.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/snapshot_storage/ingested'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def live_snapshot_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get live snapshot storage for all snapshots.

        Get live snapshot storage for all snapshots.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/snapshot_storage/live'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def logical_snapshot_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get logical storage for all snapshots.

        Get logical storage for all snapshots.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/snapshot_storage/logical'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def physical_snapshot_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get physical storage for all snapshots.

        Get physical storage for all snapshots.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/snapshot_storage/physical'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def streams(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the number of concurent streams.

        Get the number of concurent streams.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/streams/count'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def system_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get entire storage info about TotalStorage, AvailableStorage,
        ReservedStorage and UsedStorage.

        Get entire storage info about TotalStorage, AvailableStorage,
        ReservedStorage and UsedStorage.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SystemStorageStats
         <rubriklib_int.models.SystemStorageStats>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SystemStorageStats
         <rubriklib_int.models.SystemStorageStats>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/system_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SystemStorageStats', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def total_physical_storage_timeseries(
            self, range, custom_headers=None, raw=False, **operation_config):
        """Get a timeseries of total physical storage growth.

        Get a timeseries of total physical storage growth.

        :param range: Range for timeseries. eg: -1h, -1min, etc. Default value
         is -1h.
        :type range: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`TimeStat <rubriklib_int.models.TimeStat>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/total_physical_storage/time_series'

        # Construct parameters
        query_parameters = {}
        query_parameters['range'] = self._serialize.query("range", range, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TimeStat]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def total_replication_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get total storage including local vm storage replicated across targets
        and also remote vm storage on premise.

        Get Total storage including local vm storage replicated across targets
        and also remote vm storage on premise.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ReplicationStorage
         <rubriklib_int.models.ReplicationStorage>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ReplicationStorage
         <rubriklib_int.models.ReplicationStorage>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/total_replication_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ReplicationStorage', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def total_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get total storage in cluster.

        Get total storage in cluster.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/total_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def unprotected_snappable_storage(
            self, custom_headers=None, raw=False, **operation_config):
        """Get total storage for snappables that have snapshots but are currently
        not protected.

        Get total storage for snappables that have snapshots but are currently
        not protected.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`OfflineStatSummary
         <rubriklib_int.models.OfflineStatSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/stats/unprotected_snappable_storage'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('OfflineStatSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_storage_arrays(
            self, custom_headers=None, raw=False, **operation_config):
        """Summary of all storage arrays.

        Retrieve the host IP and username for all storage arrays.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`StorageArrayDetailListResponse
         <rubriklib_int.models.StorageArrayDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`StorageArrayDetailListResponse
         <rubriklib_int.models.StorageArrayDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/storage/array'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('StorageArrayDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def add_storage_array(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Add a new storage array.

        Add a new storage array.

        :param definition: JSON object for storage array definition.
        :type definition: :class:`StorageArrayDefinition
         <rubriklib_int.models.StorageArrayDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`StorageArrayDetail
         <rubriklib_int.models.StorageArrayDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`StorageArrayDetail
         <rubriklib_int.models.StorageArrayDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/storage/array'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'StorageArrayDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('StorageArrayDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_storage_array(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information about a specific storage array.

        Get information about a specific storage array.

        :param id: ID of the storage array.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`StorageArrayDetail
         <rubriklib_int.models.StorageArrayDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`StorageArrayDetail
         <rubriklib_int.models.StorageArrayDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/storage/array/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('StorageArrayDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_storage_array(
            self, id, definition, custom_headers=None, raw=False, **operation_config):
        """Update a specific storage array.

        Update the host ip, username, and/or password of given storage array.

        :param id: ID of the storage array to update.
        :type id: str
        :param definition: JSON object for storage array definition.
        :type definition: :class:`StorageArrayDefinition
         <rubriklib_int.models.StorageArrayDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`StorageArrayDetail
         <rubriklib_int.models.StorageArrayDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`StorageArrayDetail
         <rubriklib_int.models.StorageArrayDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/storage/array/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'StorageArrayDefinition')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('StorageArrayDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_storage_array_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Remove a specific storage array.

        Remove a specific storage array.

        :param id: ID of the storage array to remove.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/storage/array/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def generate_support_bundle(
            self, definitions=None, custom_headers=None, raw=False, **operation_config):
        """Collect log files from the cluster.

        To be used by Admin to collect necessary Rubrik's log files from all
        the nodes. Both event_id and reqeust_ids are optional. If nothing is
        specified, the whole support bundle is to be collected, if event_id is
        specified, the reqeuest_ids is ignored. If request id is specified,
        only collect logs related to the specific request, otherwise collect
        all the logs.

        :param definitions: Either event id or request id list of the request
         to be collected, if both are provided, request id list would be
         ignored
        :type definitions: :class:`GenerateSupportBundleRequest
         <rubriklib_int.models.GenerateSupportBundleRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/support/support_bundle'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if definitions is not None:
            body_content = self._serialize.body(definitions, 'GenerateSupportBundleRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_support_bundle(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get the status of generating support bundle.

        Given a request ID for generate support bundle request, provide the
        status of the request. If the request is successful, the download link
        for the support bundle would be included.

        :param id: The support bundle generation request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/support/support_bundle'

        # Construct parameters
        query_parameters = {}
        query_parameters['id'] = self._serialize.query("id", id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def tunnel_status_method(
            self, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Check support tunnel status.

        To be used by Admin to check status of the support tunnel.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`TunnelStatus <rubriklib_int.models.TunnelStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`TunnelStatus <rubriklib_int.models.TunnelStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/support/tunnel'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TunnelStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_tunnel(
            self, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Create SSH Tunnel for Support Access.

        To be used by Admin to open a SSH tunnel for support.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`TunnelStatus <rubriklib_int.models.TunnelStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`TunnelStatus <rubriklib_int.models.TunnelStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/support/tunnel'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TunnelStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def close_tunnel(
            self, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Remove SSH Tunnel for Support Access.

        To be used by Admin to close an established SSH tunnel.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`TunnelStatus <rubriklib_int.models.TunnelStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`TunnelStatus <rubriklib_int.models.TunnelStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/support/tunnel'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TunnelStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_syslog(
            self, custom_headers=None, raw=False, **operation_config):
        """Get configured Syslog Server export settings.

        Returns the list of all configured Syslog Server export settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SyslogServerSettingsListResponse
         <rubriklib_int.models.SyslogServerSettingsListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SyslogServerSettingsListResponse
         <rubriklib_int.models.SyslogServerSettingsListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/syslog'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SyslogServerSettingsListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def configure_syslog_server_settings(
            self, syslog_settings, custom_headers=None, raw=False, **operation_config):
        """Configure new Syslog Server export settings.

        Configures new Syslog Server export settings to be used for Syslog
        export.

        :param syslog_settings: New Syslog Server export settings.
        :type syslog_settings: :class:`SyslogServerSettingsUpdate
         <rubriklib_int.models.SyslogServerSettingsUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SyslogServerSettings
         <rubriklib_int.models.SyslogServerSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SyslogServerSettings
         <rubriklib_int.models.SyslogServerSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/syslog'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(syslog_settings, 'SyslogServerSettingsUpdate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('SyslogServerSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def test_syslog_server_export_settings(
            self, syslog_settings, custom_headers=None, raw=False, **operation_config):
        """Test Syslog Server export settings.

        Sends a test message using a given Syslog Server export settings.

        :param syslog_settings: Syslog Server export settings.
        :type syslog_settings: :class:`SyslogServerSettingsUpdate
         <rubriklib_int.models.SyslogServerSettingsUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: object or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/syslog/test'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(syslog_settings, 'SyslogServerSettingsUpdate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SyslogServerTestResult', response)
        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_syslog_server_settings(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get Syslog Server export settings for a configured Syslog Server.

        Gets the Syslog Server export settings of a configured Syslog Server
        with the given ID.

        :param id: The ID of Syslog Server export settings.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SyslogServerSettings
         <rubriklib_int.models.SyslogServerSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SyslogServerSettings
         <rubriklib_int.models.SyslogServerSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/syslog/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SyslogServerSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_syslog_server_settings(
            self, id, syslog_settings, custom_headers=None, raw=False, **operation_config):
        """Modify Syslog Server export settings.

        Modify the export settings for a single Syslog Server.

        :param id: The ID of Syslog Server export settings.
        :type id: str
        :param syslog_settings: Syslog Server export settings.
        :type syslog_settings: :class:`SyslogServerSettingsUpdate
         <rubriklib_int.models.SyslogServerSettingsUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SyslogServerSettings
         <rubriklib_int.models.SyslogServerSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SyslogServerSettings
         <rubriklib_int.models.SyslogServerSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/syslog/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(syslog_settings, 'SyslogServerSettingsUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SyslogServerSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_syslog_server_settings(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete Syslog Server export settings.

        Delete the Syslog Server export settings by specifying the settings ID.

        :param id: The ID of Syslog Server export settings.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/syslog/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 404:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_throttling_settings(
            self, custom_headers=None, raw=False, **operation_config):
        """Get the throttling settings.

        Get the throttling settings.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ThrottlingSettings
         <rubriklib_int.models.ThrottlingSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ThrottlingSettings
         <rubriklib_int.models.ThrottlingSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/throttle'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ThrottlingSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_throttling_settings(
            self, settings, custom_headers=None, raw=False, **operation_config):
        """Change the throttling settings.

        Change the throttling settings. This request will completely replace
        the existing settings. So if a field is not specified, it will be
        cleared and will not be used for throttling.

        :param settings: New throttling settings
        :type settings: :class:`ThrottlingSettings
         <rubriklib_int.models.ThrottlingSettings>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ThrottlingSettings
         <rubriklib_int.models.ThrottlingSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ThrottlingSettings
         <rubriklib_int.models.ThrottlingSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/throttle'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(settings, 'ThrottlingSettings')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ThrottlingSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_unmanaged_object(
            self, limit=None, after_id=None, search_value=None, unmanaged_status=None, object_type=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary of all the objects with unmanaged snapshots.

        Get summary of all the objects with unmanaged snapshots.

        :param limit: Limit the number of matches returned.
        :type limit: int
        :param after_id: First unmanaged object after which objects should be
         retrieved
        :type after_id: str
        :param search_value: Search object by object name.
        :type search_value: str
        :param unmanaged_status: Filter by the type of the object. If not
         specified, will return all objects. Valid attributes are Protected,
         Relic and Unprotected. Possible values include: 'Protected', 'Relic',
         'Unprotected'
        :type unmanaged_status: str
        :param object_type: Filter by the type of the unmanaged object.
         Possible values include: 'VirtualMachine', 'MssqlDatabase',
         'LinuxFileset', 'WindowsFileset', 'ShareFileset', 'NutanixVm',
         'HypervVm', 'ManagedVolume'
        :type object_type: str
        :param sort_by: Sort the result by given attribute. Possible values
         include: 'Name', 'UnmanagedStatus', 'Location',
         'UnmanagedSnapshotCount', 'LocalStorage', 'ArchiveStorage'
        :type sort_by: str
        :param sort_order: The sort order. Defaults to asc if not specified.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UnmanagedObjectSummaryListResponse
         <rubriklib_int.models.UnmanagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UnmanagedObjectSummaryListResponse
         <rubriklib_int.models.UnmanagedObjectSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/unmanaged_object'

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if after_id is not None:
            query_parameters['after_id'] = self._serialize.query("after_id", after_id, 'str')
        if search_value is not None:
            query_parameters['search_value'] = self._serialize.query("search_value", search_value, 'str')
        if unmanaged_status is not None:
            query_parameters['unmanaged_status'] = self._serialize.query("unmanaged_status", unmanaged_status, 'str')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UnmanagedObjectSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_delete_unmanaged_object_snapshots_method(
            self, delete_unmanaged_config, custom_headers=None, raw=False, **operation_config):
        """Bulk delete all unmanaged snapshots for the given objects.

        Bulk delete all unmanaged snapshots for the objects specified by
        objectId/objectType pairings.

        :param delete_unmanaged_config: List of objectId/objectType pairings
         for which to delete all snapshots
        :type delete_unmanaged_config:
         :class:`BulkDeleteUnmanagedObjectSnapshots
         <rubriklib_int.models.BulkDeleteUnmanagedObjectSnapshots>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/unmanaged_object/snapshot/bulk_delete'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(delete_unmanaged_config, 'BulkDeleteUnmanagedObjectSnapshots')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_unmanaged_object_snapshots(
            self, id, limit=None, offset=None, search_value=None, search_timezone_offset=None, unmanaged_snapshot_type=None, before_date=None, after_date=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary of all the unmanaged snapshots for a given object.

        Get summary of all the unmanaged snapshots for the object specified by
        id.

        :param id: ID of a object.
        :type id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param search_value: Search snapshot by Date and Time.
        :type search_value: str
        :param search_timezone_offset: The timezone offset with which to
         search by Date and Time against, in minutes.
        :type search_timezone_offset: int
        :param unmanaged_snapshot_type: Filter by Unmanaged Snapshot Type.
         Valid attributes are OnDemand, Retrieved, Relic, and Unprotected.
         Possible values include: 'OnDemand', 'Retrieved', 'Relic',
         'Unprotected'
        :type unmanaged_snapshot_type: str
        :param before_date: Filter all the snapshots before a date.
        :type before_date: datetime
        :param after_date: Filter all the snapshots after a date.
        :type after_date: datetime
        :param sort_by: Sort by given attribute. Possible values include:
         'SnapshotDateAndTime', 'UnmanagedSnapshotType', 'LocalStorage',
         'ArchiveStorage'
        :type sort_by: str
        :param sort_order: The sort order. Defaults to asc if not specified.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UnmanagedSnapshotSummaryListResponse
         <rubriklib_int.models.UnmanagedSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UnmanagedSnapshotSummaryListResponse
         <rubriklib_int.models.UnmanagedSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/unmanaged_object/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if search_value is not None:
            query_parameters['search_value'] = self._serialize.query("search_value", search_value, 'str')
        if search_timezone_offset is not None:
            query_parameters['search_timezone_offset'] = self._serialize.query("search_timezone_offset", search_timezone_offset, 'int')
        if unmanaged_snapshot_type is not None:
            query_parameters['unmanaged_snapshot_type'] = self._serialize.query("unmanaged_snapshot_type", unmanaged_snapshot_type, 'str')
        if before_date is not None:
            query_parameters['before_date'] = self._serialize.query("before_date", before_date, 'iso-8601')
        if after_date is not None:
            query_parameters['after_date'] = self._serialize.query("after_date", after_date, 'iso-8601')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UnmanagedSnapshotSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def bulk_delete_unmanaged_snapshots_for_object(
            self, id, delete_snapshots_config, custom_headers=None, raw=False, **operation_config):
        """Bulk delete specified unmanaged snapshots for the given object. Must
        specify object type as well.

        Bulk delete unmanaged snapshots specified by snapshotIds for the given
        object.

        :param id: ID of the object.
        :type id: str
        :param delete_snapshots_config: List of snapshotIds to delete and the
         type of object the snapshots are of.
        :type delete_snapshots_config:
         :class:`BulkDeleteUnmanagedSnapshotsConfig
         <rubriklib_int.models.BulkDeleteUnmanagedSnapshotsConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`RequestFailedException
         <rubriklib_int.models.RequestFailedException>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/unmanaged_object/{id}/snapshot/bulk_delete'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(delete_snapshots_config, 'BulkDeleteUnmanagedSnapshotsConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 409:
            deserialized = self._deserialize('RequestFailedException', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_user(
            self, username=None, auth_domain_id=None, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Summary of all the Users .

        To be used by Admin to fetch the list of Users.

        :param username: Username to match
        :type username: str
        :param auth_domain_id: Auth domain ID to match
        :type auth_domain_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`UserSummary
         <rubriklib_int.models.UserSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`UserSummary
         <rubriklib_int.models.UserSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user'

        # Construct parameters
        query_parameters = {}
        if username is not None:
            query_parameters['username'] = self._serialize.query("username", username, 'str')
        if auth_domain_id is not None:
            query_parameters['auth_domain_id'] = self._serialize.query("auth_domain_id", auth_domain_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserSummary]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_user(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Create new User.

        To be used by Admin to create new User.

        :param definition: Detail info about the user to be created
        :type definition: :class:`UserDefinition
         <rubriklib_int.models.UserDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UserDetail <rubriklib_int.models.UserDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UserDetail <rubriklib_int.models.UserDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'UserDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user(
            self, id, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Details about the specific User.

        To be used by Admin to fetch details about the specific User.

        :param id: ID of the User that needs to be fetched
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UserDetail <rubriklib_int.models.UserDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UserDetail <rubriklib_int.models.UserDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_user(
            self, id, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Delete a user for the given id.

        Delete a user for the given id.

        :param id: ID of the user to be deleted
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: str or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_user(
            self, id, user_info, custom_headers=None, raw=False, **operation_config):
        """ADMIN ONLY: Update existing User.

        To be used by Admin to update existing User.

        :param id: ID of the User that needs to be updated
        :type id: str
        :param user_info: User info to be updated
        :type user_info: :class:`UserUpdateInfo
         <rubriklib_int.models.UserUpdateInfo>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UserDetail <rubriklib_int.models.UserDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UserDetail <rubriklib_int.models.UserDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(user_info, 'UserUpdateInfo')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_user_notification(
            self, limit=None, after_id=None, state=None, status=None, notification_type=None, object_ids=None, before_date=None, after_date=None, object_type=None, custom_headers=None, raw=False, **operation_config):
        """Get notifications for the current user.

        Notifications for the current user.

        :param limit: Maximum number of notifications retrieved
        :type limit: int
        :param after_id: Retrieve notifications after given notification id.
         Combined with the limit parameter, this allows paginated query for
         notifications.
        :type after_id: str
        :param state: Filter by State. Possible values include: 'NEW', 'READ'
        :type state: str
        :param status: Filter by Status. Possible values include: 'Failure',
         'Warning', 'Success'
        :type status: str
        :param notification_type: Filter by Notification Type. Possible values
         include: 'Backup', 'Configuration', 'Recovery', 'SlaViolation',
         'ProtectionState', 'Hardware', 'Support'
        :type notification_type: str
        :param object_ids: Filter by a comma separated list of object IDs.
        :type object_ids: list of str
        :param before_date: Filter all the notifications before a date.
        :type before_date: datetime
        :param after_date: Filter all the notifications after a date.
        :type after_date: datetime
        :param object_type: Filter all the notifications by object type. Enter
         any of the following values: **VmwareVm**, **SlaDomain**,
         **DataLocation**, **Cluster**, **MountVm**, **LinuxFileset**,
         **ShareFileset**, **WindowsFileset**, **NutanixVm**, **HypervVm**,
         **ManagedVolume**, or **Mssql**
        :type object_type: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`UserNotificationDetail
         <rubriklib_int.models.UserNotificationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`UserNotificationDetail
         <rubriklib_int.models.UserNotificationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user_notification'

        # Construct parameters
        query_parameters = {}
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if after_id is not None:
            query_parameters['after_id'] = self._serialize.query("after_id", after_id, 'str')
        if state is not None:
            query_parameters['state'] = self._serialize.query("state", state, 'str')
        if status is not None:
            query_parameters['status'] = self._serialize.query("status", status, 'str')
        if notification_type is not None:
            query_parameters['notification_type'] = self._serialize.query("notification_type", notification_type, 'str')
        if object_ids is not None:
            query_parameters['object_ids'] = self._serialize.query("object_ids", object_ids, '[str]', div=',')
        if before_date is not None:
            query_parameters['before_date'] = self._serialize.query("before_date", before_date, 'iso-8601')
        if after_date is not None:
            query_parameters['after_date'] = self._serialize.query("after_date", after_date, 'iso-8601')
        if object_type is not None:
            query_parameters['object_type'] = self._serialize.query("object_type", object_type, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserNotificationDetail]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def user_notification_bulk_update(
            self, update_detail, custom_headers=None, raw=False, **operation_config):
        """Update user notification state in bulk.

        Update user notification state in bulk. For each notification state,
        enter any of the following values: **NEW** or **READ**.

        :param update_detail: user notifications to update
        :type update_detail: :class:`BulkUpdateDetail
         <rubriklib_int.models.BulkUpdateDetail>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`UserNotificationDetail
         <rubriklib_int.models.UserNotificationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`UserNotificationDetail
         <rubriklib_int.models.UserNotificationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user_notification/update/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_detail, 'BulkUpdateDetail')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserNotificationDetail]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def patch_user_notification(
            self, notification_id, state, custom_headers=None, raw=False, **operation_config):
        """Change status of given notification.

        Change status of given notification.

        :param notification_id: ID of notification
        :type notification_id: str
        :param state: State to update. Enter any of the following values:
         **NEW** or **READ**.
        :type state: :class:`UpdateDetail <rubriklib_int.models.UpdateDetail>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`UserNotificationDetail
         <rubriklib_int.models.UserNotificationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`UserNotificationDetail
         <rubriklib_int.models.UserNotificationDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/user_notification/{notification_id}'
        path_format_arguments = {
            'notification_id': self._serialize.url("notification_id", notification_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(state, 'UpdateDetail')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserNotificationDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_vm_agent_deployment_setting(
            self, custom_headers=None, raw=False, **operation_config):
        """Get Rubrik Backup Service deployment setting.

        Retrieve the global setting for automatic deployment of the Rubrik
        Backup Service to virtual machines.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AgentDeploymentSettings
         <rubriklib_int.models.AgentDeploymentSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AgentDeploymentSettings
         <rubriklib_int.models.AgentDeploymentSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/agent'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AgentDeploymentSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_vm_agent_deployment_setting(
            self, settings, custom_headers=None, raw=False, **operation_config):
        """Change the Rubrik Backup Service deployment setting.

        Modify the global setting for automatic deployment of the Rubrik Backup
        Service to virtual machines.

        :param settings: Modify the Rubrik Backup Service deployment setting
         for a specified virtual machine.
        :type settings: :class:`AgentDeploymentSettings
         <rubriklib_int.models.AgentDeploymentSettings>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AgentDeploymentSettings
         <rubriklib_int.models.AgentDeploymentSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AgentDeploymentSettings
         <rubriklib_int.models.AgentDeploymentSettings>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/agent'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(settings, 'AgentDeploymentSettings')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AgentDeploymentSettings', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_compute_cluster(
            self, data_center_id=None, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get all the clusters belonging to this datacenter.

        Get all the clusters belonging to this datacenter.

        :param data_center_id: Filter clusters on data center ID
        :type data_center_id: str
        :param primary_cluster_id: Filter on a primary cluster ID. Also
         accepts value 'local'
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ComputeClusterSummaryListResponse
         <rubriklib_int.models.ComputeClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ComputeClusterSummaryListResponse
         <rubriklib_int.models.ComputeClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/compute_cluster'

        # Construct parameters
        query_parameters = {}
        if data_center_id is not None:
            query_parameters['data_center_id'] = self._serialize.query("data_center_id", data_center_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ComputeClusterSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_compute_cluster(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details for the compute cluster.

        Get details for the compute cluster.

        :param id: id of the compute cluster
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ComputeClusterDetail
         <rubriklib_int.models.ComputeClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ComputeClusterDetail
         <rubriklib_int.models.ComputeClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/compute_cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ComputeClusterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_data_center(
            self, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Gets the list of all the data centers.

        Returns the summary of all the data centers.

        :param primary_cluster_id: Filter by Primary cluster ID, or local
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list of :class:`DataCenterSummary
         <rubriklib_int.models.DataCenterSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: list of :class:`DataCenterSummary
         <rubriklib_int.models.DataCenterSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/data_center'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DataCenterSummary]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_data_center(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets details about the specific DataCenter.

        Returns details about the specific DataCenter.

        :param id: ID of the data center that needs to be fetched
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DataCenterDetail
         <rubriklib_int.models.DataCenterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DataCenterDetail
         <rubriklib_int.models.DataCenterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/data_center/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DataCenterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_datastore(
            self, custom_headers=None, raw=False, **operation_config):
        """Get summaries of all the DataStores.

        Get summaries of all the DataStores.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DataStoreSummaryListResponse
         <rubriklib_int.models.DataStoreSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DataStoreSummaryListResponse
         <rubriklib_int.models.DataStoreSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/datastore'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DataStoreSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_datastore(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about the specific DataStore.

        Get details about the specific DataStore.

        :param id: ID of the DataStore that needs to be fetched
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`DataStoreDetail
         <rubriklib_int.models.DataStoreDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`DataStoreDetail
         <rubriklib_int.models.DataStoreDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/datastore/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DataStoreDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_guest_credential(
            self, custom_headers=None, raw=False, **operation_config):
        """Summary of all guest OS credentials.

        Retrieve the ID, domain, username and password for all guest OS
        credentials.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GuestCredentialDetailListResponse
         <rubriklib_int.models.GuestCredentialDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GuestCredentialDetailListResponse
         <rubriklib_int.models.GuestCredentialDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/guest_credential'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GuestCredentialDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_guest_credential(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Create a new guest OS credential.

        Create a new guest OS credential.

        :param definition: Object for guest OS credential definition.
        :type definition: :class:`GuestCredentialDefinition
         <rubriklib_int.models.GuestCredentialDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GuestCredentialDetail
         <rubriklib_int.models.GuestCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GuestCredentialDetail
         <rubriklib_int.models.GuestCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/guest_credential'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'GuestCredentialDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('GuestCredentialDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_guest_credential(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information about a specific guest OS credential.

        Get information about a specific guest OS credential.

        :param id: ID of the guest OS credential.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GuestCredentialDetail
         <rubriklib_int.models.GuestCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GuestCredentialDetail
         <rubriklib_int.models.GuestCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/guest_credential/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GuestCredentialDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_guest_credential(
            self, id, definition, custom_headers=None, raw=False, **operation_config):
        """Update a specific guest OS credential.

        Update the domain, username and password of given guest OS credential.

        :param id: ID of the guest OS credential to update.
        :type id: str
        :param definition: Object for guest OS credential definition.
        :type definition: :class:`GuestCredentialDefinition
         <rubriklib_int.models.GuestCredentialDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`GuestCredentialDetail
         <rubriklib_int.models.GuestCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`GuestCredentialDetail
         <rubriklib_int.models.GuestCredentialDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/guest_credential/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'GuestCredentialDefinition')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GuestCredentialDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_guest_credential_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Remove a specific guest OS credential.

        Remove a specific guest OS credential.

        :param id: ID of the guest OS credential to remove.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/guest_credential/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def create_refresh_vm(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Refresh single virtual machine metadata in a vcenter.

        Refresh a single virtual machine metadata in a vcenter.

        :param id: ID of the vCenter Server
        :type id: str
        :param config: Configuration of the vm request to refresh
        :type config: :class:`RefreshVmRequest
         <rubriklib_int.models.RefreshVmRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vcenter/{id}/refresh_vm'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'RefreshVmRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def count_vm(
            self, custom_headers=None, raw=False, **operation_config):
        """Count of all the local non-archived VMs.

        Count of all the local non-archived VMs.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/count'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_credential_failure_vms(
            self, custom_headers=None, raw=False, **operation_config):
        """Fetch VMs with authentication failures.

        Fetch VMs with authentication failures.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualMachineBriefListResponse
         <rubriklib_int.models.VirtualMachineBriefListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualMachineBriefListResponse
         <rubriklib_int.models.VirtualMachineBriefListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/credential_failure'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualMachineBriefListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def credential_failure_count(
            self, custom_headers=None, raw=False, **operation_config):
        """Fetch count of VMs with authentication failures.

        Fetch count of VMs with authentication failures.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/credential_failure/count'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def live_snapshot_count(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Count of all the live snapshots of a VM.

        Count of all the live snapshots of a VM.

        :param id: ID of the Virtual Machine
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/live_snapshot/count/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def count_snapshot(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a count of snapshots.

        Retrieve total number of snapshots.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/count'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_mount(
            self, vm_id=None, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all live mounts.

        Retrieve the following information for all live mounts: ID, snapshot
        date, ID of source VM, name of source VM, ID of source host, status of
        the mount, mount event ID, and unmount event ID.

        :param vm_id: Filters live mounts by VM ID
        :type vm_id: str
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param limit: Limit the number of matches returned. Default is 25.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareVmMountSummaryListResponse
         <rubriklib_int.models.VmwareVmMountSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareVmMountSummaryListResponse
         <rubriklib_int.models.VmwareVmMountSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/mount'

        # Construct parameters
        query_parameters = {}
        if vm_id is not None:
            query_parameters['vm_id'] = self._serialize.query("vm_id", vm_id, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareVmMountSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def count_mount(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a count of live mounts.

        Retrieve total number of live mounts.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`CountResponse <rubriklib_int.models.CountResponse>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`CountResponse <rubriklib_int.models.CountResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/mount/count'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CountResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mount(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary information for a live mount.

        Retrieve the following summary information for a specified live mount:
        ID, snapshot date, ID of source VM, name of source VM, ID of source
        host, status of the mount, mount event ID, and unmount event ID.

        :param id: ID of the live mount
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MountDetail <rubriklib_int.models.MountDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MountDetail <rubriklib_int.models.MountDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MountDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_mount(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Create a live mount request.

        Create a live mount request with given configuration.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for the mount request
        :type config: :class:`MountSnapshotJobConfig
         <rubriklib_int.models.MountSnapshotJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/{id}/mount'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'MountSnapshotJobConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_restore_files_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Restores multiple files/directories from VM snapshot.

        Create a request to restore multiple file or folder to the source
        virtual machine.

        :param id: ID of a snapshot.
        :type id: str
        :param config: Configuration for the restore request.
        :type config: :class:`RestoreFilesJobConfig
         <rubriklib_int.models.RestoreFilesJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/{id}/restore_files'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'RestoreFilesJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_standalone_export(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Create an export request to standalone esx server.

        Export snapshot of a vm to stanadlone esx server.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for the export request to standalone esx
         host
        :type config: :class:`ExportSnapshotToStandaloneHostRequest
         <rubriklib_int.models.ExportSnapshotToStandaloneHostRequest>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib_int.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/snapshot/{id}/standalone_esx_host_export'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'ExportSnapshotToStandaloneHostRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def vm_bulk_update(
            self, update, custom_headers=None, raw=False, **operation_config):
        """Update VMs in bulk.

        Update VMs with specified properties.

        :param update: Properties to update
        :type update: :class:`VirtualMachineBulkUpdate
         <rubriklib_int.models.VirtualMachineBulkUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: dict or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: dict or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/update/bulk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'VirtualMachineBulkUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('{VmEndPointStatus}', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_virtual_disk(
            self, custom_headers=None, raw=False, **operation_config):
        """Get a list of all the Virtual Disks.

        Get a list of all the Virtual Disks.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualDiskSummaryListResponse
         <rubriklib_int.models.VirtualDiskSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualDiskSummaryListResponse
         <rubriklib_int.models.VirtualDiskSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/virtual_disk'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualDiskSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def vm_register_agent(
            self, id, custom_headers=None, raw=False, **operation_config):
        """register the agent installed in vm.

        Register the agent that installed in vm.

        :param id: ID of the Virtual Machine
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/internal/vmware/vm/{id}/register_agent'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
